// lib/audience/model.ts
// Audience Model types and Zod schemas for Audience Lab
//
// The Audience Model is a structured representation of audience segments
// that is curated in Audience Lab and written to the Context Graph.

import { z } from 'zod';
import { MediaChannelId } from '@/lib/contextGraph/enums';

// ============================================================================
// Demand States
// ============================================================================

export const DemandState = z.enum([
  'unaware',          // Not aware of the problem or solution
  'problem_aware',    // Aware of the problem, not solutions
  'solution_aware',   // Aware solutions exist, evaluating options
  'in_market',        // Actively shopping/comparing
  'post_purchase',    // Already purchased, potential upsell/referral
]);

export type DemandState = z.infer<typeof DemandState>;

export const DEMAND_STATE_LABELS: Record<DemandState, string> = {
  unaware: 'Unaware',
  problem_aware: 'Problem Aware',
  solution_aware: 'Solution Aware',
  in_market: 'In-Market',
  post_purchase: 'Post-Purchase',
};

export const DEMAND_STATE_DESCRIPTIONS: Record<DemandState, string> = {
  unaware: 'Not yet aware of the problem or that solutions exist',
  problem_aware: 'Recognizes the problem but not exploring solutions',
  solution_aware: 'Knows solutions exist and is evaluating options',
  in_market: 'Actively shopping and ready to make a decision',
  post_purchase: 'Already a customer, potential for upsell or referral',
};

// ============================================================================
// Audience Segment
// ============================================================================

export const AudienceSegment = z.object({
  id: z.string(),
  name: z.string(),
  description: z.string().optional(),

  // Jobs to be done, pains, and triggers
  jobsToBeDone: z.array(z.string()).default([]),
  keyPains: z.array(z.string()).default([]),
  keyGoals: z.array(z.string()).default([]),

  // Demand states
  primaryDemandState: DemandState.optional(),
  secondaryDemandStates: z.array(DemandState).default([]),

  // Demographic / geo descriptors
  demographics: z.string().optional(),
  geos: z.string().optional(),

  // Behavioral + media habits
  behavioralDrivers: z.array(z.string()).default([]),
  mediaHabits: z.string().optional(),

  // Objections and decision factors
  keyObjections: z.array(z.string()).default([]),
  proofPointsNeeded: z.array(z.string()).default([]),

  // Channel & creative hints (for Media/Creative Labs)
  priorityChannels: z.array(MediaChannelId).default([]),
  avoidChannels: z.array(MediaChannelId).default([]),
  creativeAngles: z.array(z.string()).default([]),
  recommendedFormats: z.array(z.string()).default([]), // UGC, explainer, carousel, etc.

  // Priority/sizing hints
  priority: z.enum(['primary', 'secondary', 'tertiary']).optional(),
  estimatedSize: z.string().optional(), // e.g., "Large", "Medium", "Small" or numeric
});

export type AudienceSegment = z.infer<typeof AudienceSegment>;

// ============================================================================
// Audience Model
// ============================================================================

export const AudienceModelSource = z.enum([
  'ai_seeded',  // Generated by AI from signals
  'manual',     // Manually created by user
  'mixed',      // Combination of AI and manual edits
]);

export type AudienceModelSource = z.infer<typeof AudienceModelSource>;

export const AudienceModel = z.object({
  id: z.string(),
  companyId: z.string(),
  version: z.number().default(1),
  updatedAt: z.string(), // ISO
  createdAt: z.string(), // ISO
  createdBy: z.string().optional(), // user id/email if available
  description: z.string().optional(), // overall audience summary
  segments: z.array(AudienceSegment),
  notes: z.string().optional(),
  source: AudienceModelSource.default('mixed'),
  isCurrentCanonical: z.boolean().default(false),
});

export type AudienceModel = z.infer<typeof AudienceModel>;

// ============================================================================
// Helper Functions
// ============================================================================

/**
 * Create an empty audience segment with a unique ID
 */
export function createEmptySegment(name: string = 'New Segment'): AudienceSegment {
  return {
    id: `seg_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
    name,
    description: '',
    jobsToBeDone: [],
    keyPains: [],
    keyGoals: [],
    primaryDemandState: undefined,
    secondaryDemandStates: [],
    demographics: '',
    geos: '',
    behavioralDrivers: [],
    mediaHabits: '',
    keyObjections: [],
    proofPointsNeeded: [],
    priorityChannels: [],
    avoidChannels: [],
    creativeAngles: [],
    recommendedFormats: [],
    priority: undefined,
    estimatedSize: undefined,
  };
}

/**
 * Create an empty audience model for a company
 */
export function createEmptyAudienceModel(
  companyId: string,
  createdBy?: string
): AudienceModel {
  const now = new Date().toISOString();
  return {
    id: `am_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
    companyId,
    version: 1,
    updatedAt: now,
    createdAt: now,
    createdBy,
    description: '',
    segments: [],
    notes: '',
    source: 'manual',
    isCurrentCanonical: false,
  };
}

/**
 * Validate an audience model
 */
export function validateAudienceModel(model: unknown): {
  valid: boolean;
  errors: string[];
  model: AudienceModel | null;
} {
  const result = AudienceModel.safeParse(model);
  if (result.success) {
    return { valid: true, errors: [], model: result.data };
  }
  return {
    valid: false,
    errors: result.error.errors.map(e => `${e.path.join('.')}: ${e.message}`),
    model: null,
  };
}

/**
 * Get a summary of an audience model for display
 */
export function getAudienceModelSummary(model: AudienceModel): {
  segmentCount: number;
  primarySegments: string[];
  demandStatesCovered: DemandState[];
  lastUpdated: string;
} {
  const primarySegments = model.segments
    .filter(s => s.priority === 'primary')
    .map(s => s.name);

  const demandStatesCovered = Array.from(
    new Set(
      model.segments
        .flatMap(s => [s.primaryDemandState, ...s.secondaryDemandStates])
        .filter((d): d is DemandState => d !== undefined)
    )
  );

  return {
    segmentCount: model.segments.length,
    primarySegments,
    demandStatesCovered,
    lastUpdated: model.updatedAt,
  };
}
