/**
 * Growth Acceleration Plan (GAP) Generator
 * 
 * Generates a structured Growth Acceleration Plan (GAP) based on website assessment.
 * Reuses existing snapshot/audit logic and extends it with actionable growth initiatives.
 * 
 * IMPORTANT:
 * - Do not hardcode site-specific insights, copy, or scores in this pipeline.
 * - All recommendations must be derived from the actual site context, metrics, or LLM outputs.
 * - When in doubt (missing data), prefer 'Not evaluated' or cautious language over guessing.
 * - All numeric scores (overallScore, potentialScoreGain, etc.) must be either:
 *   - computed algorithmically from underlying metrics/ratings; or
 *   - generated by the LLM based on qualitative assessment.
 * - Never inject canned, site-specific sounding copy that is not derived from the target site's real context.
 */

import { generateFullAssessment, type AssessmentResult } from '@/lib/unified-assessment';
import type {
  GrowthAccelerationPlan,
  GrowthAction,
  QuickWin,
  StrategicInitiative,
  GrowthFocusArea,
  ResourceRequirement,
  Scorecard,
  Opportunity,
  ExecutiveSummary,
  SectionAnalysis,
  CompetitorAnalysis,
  MarketAnalysis,
  PositioningAnalysis,
  DataAvailability,
  GAPDebug,
} from './types';
import type { GrowthAccelerationPlanFallback } from './schema';
import OpenAI from 'openai';
import { env } from '@/lib/env';
import {
  analyzeWebsiteAndConversion,
  analyzeSeoAndVisibility,
  analyzeContentAndMessaging,
  analyzeBrandAndPositioning,
  extractTechnicalSeoSignals,
} from './section-analyses';
import { analyzeCompetitors } from './analyzeCompetitors';
import { analyzeMarket } from './analyzeMarket';
import { analyzePositioning } from './analyzePositioning';
import { analyzeContentInventory, type ContentInventory } from './analyzeContentInventory';
import type { TechnicalSeoSignals } from './types';
import { buildDimensionScores, scoreAll, scoreDimension, applyScoreFloors } from './scoring';
import { calibrateScores } from '@/lib/gap/calibration';

// ============================================================================
// TIMEOUT CONFIGURATION
// ============================================================================
// Local development has 300s (5 min), Vercel has 60s limit
// When running in Inngest background jobs, we can afford much longer timeouts
// Adjust based on environment
const IS_LOCAL = !process.env.VERCEL && process.env.NODE_ENV !== 'production';

// For background jobs, use very long timeouts (or effectively no timeout)
// We'll use 10 minutes as a safety measure, but it can be even longer
const _MAX_GENERATION_TIME = IS_LOCAL ? 600000 : 50000; // 10 minutes local, 50s production
const QUICK_WINS_TIMEOUT = IS_LOCAL ? 600000 : 10000; // 10 minutes local (no effective timeout), 10s production
const STRATEGIC_INITIATIVES_TIMEOUT = IS_LOCAL ? 600000 : 15000; // 10 minutes local (no effective timeout), 15s production
const SECTION_ANALYSIS_TIMEOUT = IS_LOCAL ? 300000 : 10000; // 5 minutes local, 10s production
const _COMPETITOR_ANALYSIS_TIMEOUT = IS_LOCAL ? 180000 : 8000; // 3 minutes local, 8s production
const _MARKET_ANALYSIS_TIMEOUT = IS_LOCAL ? 180000 : 8000; // 3 minutes local, 8s production

if (IS_LOCAL) {
  console.log('[GAP Generation] Running in LOCAL mode with extended timeouts:');
  console.log(`  - Quick Wins: ${QUICK_WINS_TIMEOUT/1000}s`);
  console.log(`  - Strategic Initiatives: ${STRATEGIC_INITIATIVES_TIMEOUT/1000}s`);
  console.log(`  - Section Analysis: ${SECTION_ANALYSIS_TIMEOUT/1000}s`);
}

// ============================================================================
// ICONIC BRAND MATURITY OVERRIDE
// ============================================================================

/**
 * List of iconic global brands that should receive maturity floor overrides
 * These brands have proven marketing systems and should not receive low scores
 */
const ICONIC_BRANDS = [
  'apple.com',
  'nike.com',
  'tesla.com',
  'google.com',
  'amazon.com',
  'shopify.com',
  'salesforce.com',
  'microsoft.com',
  'meta.com',
  'facebook.com',
  'instagram.com',
  'netflix.com',
  'spotify.com',
  'airbnb.com',
  'uber.com',
  'stripe.com',
  'slack.com',
  'zoom.us',
  'adobe.com',
  'oracle.com',
  'ibm.com',
  'intel.com',
  'cisco.com',
];

/**
 * Check if a domain is an iconic brand
 */
function isIconicBrand(url: string): boolean {
  try {
    const domain = new URL(url).hostname.toLowerCase().replace(/^www\./, '');
    return ICONIC_BRANDS.some(brand => domain === brand || domain.endsWith(`.${brand}`));
  } catch {
    return false;
  }
}

/**
 * Check if HTML extraction failed or is minimal
 */
function isHtmlExtractionFailed(html: string | undefined): boolean {
  if (!html) return true;

  // Check if HTML is too small (< 10kb typically indicates failure or bot block)
  if (html.length < 10000) return true;

  // Check for common bot-block indicators
  const lowerHtml = html.toLowerCase();
  if (lowerHtml.includes('403 forbidden') ||
      lowerHtml.includes('401 unauthorized') ||
      lowerHtml.includes('access denied') ||
      lowerHtml.includes('cloudflare') && lowerHtml.includes('checking your browser')) {
    return true;
  }

  return false;
}

/**
 * Apply maturity override for iconic brands or failed HTML extraction
 * Returns minimum scores that should be applied
 */
function getMaturityOverride(url: string, html?: string): {
  shouldOverride: boolean;
  reason: string;
  minScores: {
    brand: number;
    content: number;
    seo: number;
    website: number;
    overall: number;
  };
} | null {
  const isIconic = isIconicBrand(url);
  const htmlFailed = isHtmlExtractionFailed(html);

  if (!isIconic && !htmlFailed) {
    return null;
  }

  let reason = '';
  if (isIconic && htmlFailed) {
    reason = 'Iconic brand with failed/minimal HTML extraction (likely dynamic/JS-rendered site)';
  } else if (isIconic) {
    reason = 'Iconic global brand with proven marketing system';
  } else {
    reason = 'HTML extraction failed (< 10kb or bot-blocked) - using maturity fallback';
  }

  return {
    shouldOverride: true,
    reason,
    minScores: {
      brand: isIconic ? 90 : 70,
      content: isIconic ? 85 : 65,
      seo: isIconic ? 80 : 60,
      website: isIconic ? 70 : 55,
      overall: isIconic ? 85 : 65,
    },
  };
}
import { scoreBrandFromSignals } from './brandScoring';
import { validateGrowthAccelerationPlan } from './schema';
import { generateExecutiveSummary, type GenerateExecutiveSummaryResult } from './generateExecutiveSummary';
import { normalizeTimeHorizon } from './timeHorizonNormalizer';
import { extractSiteFeatures, type EvaluationInput } from '@/lib/eval/extractSiteFeatures';
import type { SiteFeatures } from '@/lib/eval/siteFeatures';
import {
  extractSiteElementContext,
  formatSiteContextForPrompt,
  formatCompetitorContextsForPrompt,
  fetchHTMLForContext,
  discoverKeyPages,
  type SiteElementContext,
  buildContentInventoryFromUrls,
  detectAnalyticsFromPages,
} from './html-context';

// ============================================================================
// Step-based State Machine Types
// ============================================================================

/**
 * Step type for the GAP generation state machine
 */
export type GapStep =
  | 'init'
  | 'assessment'
  | 'fetch_html'
  | 'extract_features'
  | 'discover_pages'
  | 'fetch_extra_pages'
  | 'content_inventory'
  | 'technical_seo'
  | 'section_website'
  | 'section_seo'
  | 'section_content'
  | 'section_brand'
  | 'quick_wins'
  | 'strategic_initiatives'
  | 'scoring'
  | 'executive_summary'
  | 'assemble_plan'
  | 'done';

/**
 * State object for step-based GAP generation
 * Holds all intermediate data and tracks progress through steps
 */
export interface GapRunState {
  // Identity
  runId: string;
  url: string;
  competitors: string[];
  step: GapStep;
  createdAt: string;
  updatedAt: string;
  error?: string | null;

  // Options
  options?: {
    snapshotId?: string;
    email?: string;
    preferences?: {
      focusAreas?: string[];
      timeHorizon?: 'immediate' | 'short_term' | 'medium_term' | 'long_term';
      resourceConstraints?: string;
    };
    enableDebug?: boolean;
    onProgress?: (finding: string, progress?: number, stage?: string) => void | Promise<void>;
  };

  // Step 1: Assessment
  assessment?: AssessmentResult | null;
  assessmentError?: Error | null;

  // Step 1.5: HTML fetch
  htmlByUrl?: Record<string, string>;
  attemptedUrls?: string[];
  successfulUrls?: string[];
  failedUrls?: string[];

  // Step 0: Features
  features?: SiteFeatures | null;

  // Step: Discover pages
  discoveredPages?: string[];

  // Step: Site element context
  siteElementContext?: SiteElementContext;
  competitorContexts?: SiteElementContext[];

  // Step: Content inventory
  contentInventory?: ContentInventory;

  // Step: Technical SEO
  technicalSeoSignals?: TechnicalSeoSignals;

  // Step: Data availability
  dataAvailability?: DataAvailability;

  // Step: Section analyses
  websiteSectionAnalysis?: SectionAnalysis;
  seoSectionAnalysis?: SectionAnalysis;
  contentSectionAnalysis?: SectionAnalysis;
  brandSectionAnalysis?: SectionAnalysis;
  websiteConversionAnalysis?: any; // WebsiteConversionAnalysis type

  // Step: Competitor/Market/Positioning
  competitorAnalysis?: CompetitorAnalysis;
  marketAnalysis?: MarketAnalysis;
  positioningAnalysis?: PositioningAnalysis;

  // Step: Quick wins
  quickWins?: QuickWin[];

  // Step: Strategic initiatives
  strategicInitiatives?: StrategicInitiative[];

  // Step: Scoring
  scorecard?: Scorecard;
  detectedMaturity?: string;

  // Step: Executive summary
  executiveSummary?: ExecutiveSummary;

  // Step: Final plan
  gapId?: string;
  plan?: GrowthAccelerationPlan;
}

/**
 * Options for processNextStep
 */
export interface ProcessStepOptions {
  hardTimeBudgetMs: number; // Maximum time to spend on this step
}

// ============================================================================
// OpenAI Client (unchanged)
// ============================================================================

// Lazy initialization to avoid build-time errors
let _openai: OpenAI | null = null;
function getOpenAI(): OpenAI {
  if (!_openai) {
    const apiKey = env.OPENAI_API_KEY || process.env.OPENAI_API_KEY;
    if (!apiKey) {
      const isProduction = process.env.NODE_ENV === 'production' || process.env.VERCEL === '1';
      throw new Error(
        isProduction
          ? 'OpenAI API key not configured. Please set OPENAI_API_KEY in Vercel project settings (Settings ‚Üí Environment Variables).'
          : 'OpenAI API key not configured. Please set OPENAI_API_KEY environment variable in your .env.local file.'
      );
    }
    _openai = new OpenAI({
      apiKey,
      timeout: 60000, // 60 seconds per request for GAP generation
    });
  }
  return _openai;
}

// ============================================================================
// Step Functions (extracted from generateGrowthAccelerationPlan)
// ============================================================================

/**
 * Helper to get logging function for a state
 */
function getLog(state: GapRunState): (msg: string) => void {
  const startTime = new Date(state.createdAt).getTime();
  return (msg: string) => {
    const elapsed = ((Date.now() - startTime) / 1000).toFixed(1);
    console.log(`[GAP:${state.runId}] [${elapsed}s] ${msg}`);
  };
}

/**
 * Helper to get progress reporter for a state
 */
function getReportProgress(state: GapRunState): (finding: string, progress?: number, stage?: string) => Promise<void> {
  const onProgress = state.options?.onProgress;
  if (!onProgress) {
    return async () => {};
  }
  return async (finding: string, progress?: number, stage?: string) => {
    const result = onProgress(finding, progress, stage);
    if (result instanceof Promise) {
      await result;
    }
  };
}

/**
 * Create initial GapRunState
 */
export function createInitialGapRunState(
  runId: string,
  url: string,
  competitors: string[] = [],
  options?: GapRunState['options']
): GapRunState {
  const now = new Date().toISOString();
  return {
    runId,
    url,
    competitors,
    step: 'init',
    createdAt: now,
    updatedAt: now,
    options,
  };
}

/**
 * Step: Initialize (no-op, just sets up logging)
 */
export async function runInitStep(state: GapRunState, _timeLeftMs: number): Promise<void> {
  const log = getLog(state);
  const reportProgress = getReportProgress(state);
  
  log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
  log('üìà GENERATING GROWTH ACCELERATION PLAN (GAP)');
  log(`üìä URL: ${state.url}`);
  if (state.competitors.length > 0) {
    log(`üîç Competitors: ${state.competitors.length}`);
    state.competitors.forEach((comp, i) => log(`   ${i + 1}. ${comp}`));
  }
  log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
  
  await reportProgress('Starting GAP analysis...', 5, 'starting');
}

/**
 * Step: Run assessment
 * Extracted from lines 257-382
 */
export async function runAssessmentStep(state: GapRunState, timeLeftMs: number): Promise<void> {
  const log = getLog(state);
  const reportProgress = getReportProgress(state);
  
  log('üîç Step 1: Running website assessment (snapshot mode for speed)...');
  await reportProgress('Running initial website assessment...', 8, 'assessment');
  
  // Check if already computed (idempotent)
  if (state.assessment) {
    log('‚úÖ Assessment already computed, skipping');
    return;
  }
  
  // Generate assessment with timeout wrapper to respect step time budget
  // Use 80% of available time to leave buffer, but cap at 6 seconds
  const assessmentTimeout = Math.min(timeLeftMs * 0.8, 6000); // Max 6 seconds
  let assessment: AssessmentResult | null = null;
  let assessmentError: Error | null = null;
  let timedOut = false;
  
  const assessmentStartTime = Date.now();
  try {
    const assessmentPromise = generateFullAssessment(state.url, {
      mode: 'snapshot', // Use snapshot mode to skip heavy operations and stay within timeout
      includeScreenshots: false, // Skip screenshots for faster generation
    });
    
    const timeoutPromise = new Promise<null>((resolve) => 
      setTimeout(() => {
        timedOut = true;
        log(`‚ö†Ô∏è  Assessment generation timed out after ${Math.round(assessmentTimeout / 1000)}s, using fallback`);
        resolve(null);
      }, assessmentTimeout)
    );
    
    assessment = await Promise.race([assessmentPromise, timeoutPromise]);
    
    const assessmentElapsed = Date.now() - assessmentStartTime;
    if (timedOut) {
      log(`‚è±Ô∏è  Assessment timed out after ${Math.round(assessmentElapsed / 1000)}s (budget: ${Math.round(assessmentTimeout / 1000)}s)`);
      assessment = null; // Ensure we use fallback
    } else if (assessment) {
      log(`‚úÖ Assessment completed successfully in ${Math.round(assessmentElapsed / 1000)}s`);
    }
  } catch (error: any) {
    const assessmentElapsed = Date.now() - assessmentStartTime;
    log(`‚ö†Ô∏è  Assessment generation failed after ${Math.round(assessmentElapsed / 1000)}s: ${error?.message || String(error)}`);
    assessmentError = error;
    assessment = null; // Ensure we use fallback
    // Don't throw - we'll build a fallback GAP plan instead
  }
  
  // If assessment failed, build a minimal fallback assessment
  if (!assessment) {
    log('üìã Building fallback assessment from minimal data...');
    await reportProgress('Assessment incomplete - building plan from available data', 9, 'assessment');
    
    // Create minimal fallback assessment (same as original code)
    assessment = {
      url: state.url,
      companyName: undefined,
      overallScore: 50, // Conservative default score
      maturityStage: 'Developing',
      maturityDescription: 'Assessment incomplete - using conservative estimates',
      brandScore: 50,
      contentScore: 50,
      websiteScore: 50,
      scorecard: {
        overallScore: 50,
        maturityStage: 'Developing',
        pillars: [],
      },
      extraction: {
        url: state.url,
        company_name: undefined,
        meta: {
          title: '',
          description: '',
        },
        hero_section: {
          headline_text: '',
          subheadline_text: '',
          cta_buttons: [],
          hero_image_description: '',
        },
        navigation: {
          primary_nav_items: [],
          secondary_nav_items: [],
        },
        sections: [],
        all_headings: [],
        all_ctas: [],
        trust_signals: {
          logos_visible: [],
          testimonials_visible: [],
          review_counts_visible: '',
          awards_visible: [],
        },
        value_props: [],
        content_depth_indicators: {
          feature_lists: [],
          benefit_lists: [],
          case_study_snippets: [],
          faq_present: false,
        },
        seo_elements: {
          h1: '',
          h2_list: [],
          h3_list: [],
          schema_detected: [],
          internal_links_detected: [],
        },
        design_and_layout: {
          visual_hierarchy_notes: '',
          cta_visibility_notes: '',
          readability_notes: '',
        },
        external_profiles: {
          linkedin_raw: '',
          gbp_raw: '',
        },
        analyticsAnalysis: {
          ga4Detected: false,
          gtmDetected: false,
          metaPixelDetected: false,
          hotjarDetected: false,
          mixpanelOrAmplitudeDetected: false,
        },
      },
      summary: 'Assessment generation timed out or failed. Plan generated from available website data.',
      topStrengths: [],
      quickWins: [],
      emergingRisks: ['Assessment data incomplete - recommendations based on limited analysis'],
      competitorTeaser: [],
      competitorAnalysis: {
        competitorsIdentified: [],
        marketLandscapeOverview: [],
        positioningComparison: {
          competitorPatterns: [],
          yourPositioning: [],
          gaps: [],
        },
        trustAndSocialProofComparison: [],
        uxAndFunnelComparison: {
          guidedOnboardingMatchingFlows: [],
          ctaClarity: [],
          stepsToEngage: [],
          profileDepth: [],
          bookingWorkflow: [],
          mobileUX: [],
          frictionPoints: [],
        },
        contentAndAuthorityComparison: {
          blogDepth: [],
          contentFreshness: [],
          educationalResources: [],
          expertPositioning: [],
          seoStructure: [],
          categoryLeadership: [],
        },
        featureSetComparison: {
          bookingTools: [],
          communicationTools: [],
          trainerVerification: [],
          guarantees: [],
          pricingVisibility: [],
          membershipOptions: [],
          appAvailability: [],
          retentionEngagementFeatures: [],
        },
        strategicOpportunities: [],
      },
      services: {
        websiteAndConversion: {
          label: 'Website & Conversion',
          description: 'Assessment incomplete',
          score: 50,
          pillars: [],
          keyInsights: [],
          roadmap: [],
        },
        contentAndEngagement: {
          label: 'Content & Engagement',
          description: 'Assessment incomplete',
          score: 50,
          pillars: [],
          keyInsights: [],
          roadmap: [],
        },
        brandingAndImpact: {
          label: 'Branding & Impact',
          description: 'Assessment incomplete',
          score: 50,
          pillars: [],
          keyInsights: [],
          roadmap: [],
        },
      },
      copySuggestions: [],
      websiteScoringAvailable: false,
      globalRoadmap: [],
    } as AssessmentResult;
  }

  console.log(`‚úÖ Assessment complete:`);
  console.log(`   - Overall Score: ${assessment.overallScore}/100`);
  console.log(`   - Maturity Stage: ${assessment.maturityStage}`);
  console.log(`   - Brand Score: ${assessment.brandScore}/100`);
  console.log(`   - Content Score: ${assessment.contentScore}/100`);
  console.log(`   - Website Score: ${assessment.websiteScore}/100`);
  
  await reportProgress(`Initial assessment: ${assessment.overallScore}/100 overall score`, 10, 'assessment');
  
  // Update state
  state.assessment = assessment;
  state.assessmentError = assessmentError || undefined;
}

/**
 * Step: Fetch HTML
 * Extracted from lines 384-410
 */
export async function runFetchHtmlStep(state: GapRunState, _timeLeftMs: number): Promise<void> {
  const log = getLog(state);
  const reportProgress = getReportProgress(state);
  
  console.log('üìÑ Step 1.5: Fetching HTML and extracting page elements...');
  await reportProgress('Fetching website HTML and analyzing structure...', 11, 'fetching-html');
  
  const htmlByUrl: Record<string, string> = state.htmlByUrl || {};
  
  // Track site crawl data availability
  const attemptedUrls: string[] = state.attemptedUrls || [state.url];
  const successfulUrls: string[] = state.successfulUrls || [];
  const failedUrls: string[] = state.failedUrls || [];
  
  // Fetch main page HTML first
  let mainPageHTML: string | null = null;
  try {
    mainPageHTML = await fetchHTMLForContext(state.url);
  } catch (htmlError: any) {
    log(`‚ö†Ô∏è  Failed to fetch HTML: ${htmlError?.message || 'Unknown error'}`);
    // Continue with empty HTML - we'll build a minimal plan
  }
  
  if (!mainPageHTML) {
    log('‚ö†Ô∏è  No HTML available - using minimal fallback data');
    mainPageHTML = ''; // Use empty string as fallback
  }
  htmlByUrl[state.url] = mainPageHTML;
  successfulUrls.push(state.url);
  console.log(`‚úÖ Fetched HTML for main page (${mainPageHTML.length} chars)`);
  await reportProgress(`Fetched homepage (${Math.round(mainPageHTML.length / 1000)}k chars)`, 11.5, 'fetching-html');
  
  // Update state
  state.htmlByUrl = htmlByUrl;
  state.attemptedUrls = attemptedUrls;
  state.successfulUrls = successfulUrls;
  state.failedUrls = failedUrls;
}

/**
 * Step: Extract features
 * Extracted from lines 412-433
 */
export async function runExtractFeaturesStep(state: GapRunState, _timeLeftMs: number): Promise<void> {
  const reportProgress = getReportProgress(state);
  
  console.log('üìä Step 0: Extracting site features from HTML...');
  await reportProgress('Extracting site features and signals...', 12, 'extracting-features');
  
  const mainPageHTML = state.htmlByUrl?.[state.url] || '';
  const input: EvaluationInput = {
    websiteUrl: state.url,
    pageHtml: mainPageHTML,
    competitors: state.competitors,
  };
  const features = extractSiteFeatures(input);
  console.log(`‚úÖ SiteFeatures extracted (${Object.keys(features).length} signal categories)`);
  
  // Report key findings
  if (features.conversions?.ctaButtonCount && features.conversions.ctaButtonCount > 0) {
    await reportProgress(`Found ${features.conversions.ctaButtonCount} call-to-action button${features.conversions.ctaButtonCount > 1 ? 's' : ''}`, 13, 'extracting-features');
  }
  if (features.content?.hasBlog) {
    await reportProgress('Blog detected - analyzing content depth...', 14, 'extracting-features');
  }
  if (features.navigation?.navItemLabels && features.navigation.navItemLabels.length > 0) {
    await reportProgress(`Analyzing ${features.navigation.navItemLabels.length} navigation item${features.navigation.navItemLabels.length > 1 ? 's' : ''}`, 15, 'extracting-features');
  }
  
  // Update state
  state.features = features;
}

/**
 * Step: Discover pages (pure function)
 * Extracted from lines 435-442
 */
export function runDiscoverPagesStep(state: GapRunState): void {
  const reportProgress = getReportProgress(state);
  
  console.log('üîç Discovering key pages from navigation and footer...');
  reportProgress('Discovering key pages from navigation...', 16, 'discovering-pages');
  
  const mainPageHTML = state.htmlByUrl?.[state.url] || '';
  const discoveredPages = discoverKeyPages(mainPageHTML, state.url);
  console.log(`‚úÖ Discovered ${discoveredPages.length} key page(s) to fetch`);
  if (discoveredPages.length > 0) {
    reportProgress(`Found ${discoveredPages.length} key page${discoveredPages.length > 1 ? 's' : ''} to analyze`, 17, 'discovering-pages');
  }
  
  // Update state
  state.discoveredPages = discoveredPages;
}

/**
 * Step: Fetch extra pages
 * Extracted from lines 444-577 (simplified - fetches discovered pages)
 */
export async function runFetchExtraPagesStep(state: GapRunState, timeLeftMs: number): Promise<void> {
  const log = getLog(state);
  const reportProgress = getReportProgress(state);
  
  const htmlByUrl = state.htmlByUrl || {};
  const attemptedUrls = state.attemptedUrls || [state.url];
  const successfulUrls = state.successfulUrls || [];
  const failedUrls = state.failedUrls || [];
  const discoveredPages = state.discoveredPages || [];
  
  // Ensure we fetch critical page types (same logic as original)
  const criticalPageTypes = [
    { pattern: /^\/(about|team|company|who-we-are)/i, type: 'about' },
    { pattern: /^\/(services|what-we-do|solutions)/i, type: 'services' },
    { pattern: /^\/(blog|insights|resources|articles)(\/|$)/i, type: 'blogIndex' },
    { pattern: /^\/(work|case-studies|portfolio|projects)(\/|$)/i, type: 'caseStudyIndex' },
    { pattern: /^\/(pricing|plans|prices)/i, type: 'pricing' },
  ];
  
  const discoveredUrlsSet = new Set(discoveredPages);

  for (const { pattern, type } of criticalPageTypes) {
    const hasType = discoveredPages.some(pageUrl => {
      try {
        const pathname = new URL(pageUrl).pathname.toLowerCase();
        return pattern.test(pathname);
      } catch {
        return false;
      }
    });
    
    if (!hasType) {
      const commonPaths: Record<string, string[]> = {
        about: ['/about', '/team', '/company', '/who-we-are'],
        services: ['/services', '/what-we-do', '/solutions'],
        blogIndex: ['/blog', '/insights', '/resources', '/articles'],
        caseStudyIndex: ['/work', '/case-studies', '/portfolio', '/projects'],
        pricing: ['/pricing', '/plans', '/prices'],
      };
      
      for (const path of commonPaths[type] || []) {
        try {
          const testUrl = new URL(path, state.url).href;
          if (!discoveredUrlsSet.has(testUrl)) {
            discoveredPages.push(testUrl);
            discoveredUrlsSet.add(testUrl);
            break;
          }
        } catch {
          // Skip invalid URLs
        }
      }
    }
  }
  
  // Fetch discovered pages (limit to 1 additional page)
  const pagesToFetch = discoveredPages.slice(0, 1).filter(pageUrl => pageUrl !== state.url && !htmlByUrl[pageUrl]);
  
  if (pagesToFetch.length > 0) {
    console.log(`üì• Fetching ${pagesToFetch.length} page(s) in parallel...`);
    const fetchPromises = pagesToFetch.map(async (pageUrl) => {
      attemptedUrls.push(pageUrl);
      try {
        const pageHTML = await Promise.race([
          fetchHTMLForContext(pageUrl),
          new Promise<string>((resolve) => setTimeout(() => resolve(''), Math.min(4000, timeLeftMs))),
        ]);
        if (pageHTML) {
          htmlByUrl[pageUrl] = pageHTML;
          successfulUrls.push(pageUrl);
          return { url: pageUrl, success: true };
        } else {
          failedUrls.push(pageUrl);
          return { url: pageUrl, success: false };
        }
      } catch (err: any) {
        log(`‚ö†Ô∏è  Failed to fetch ${pageUrl}: ${err?.message || 'Unknown error'}`);
        failedUrls.push(pageUrl);
        return { url: pageUrl, success: false };
      }
    });
    
    await Promise.allSettled(fetchPromises);
  }
  
  // Extract site element context from fetched pages
  await reportProgress('Extracting structured content from pages...', 18, 'extracting-context');
  const siteElementContext = extractSiteElementContext(htmlByUrl, state.url);
  console.log(`‚úÖ Site element context extracted (${siteElementContext.pages.length} pages)`);
  
  if (siteElementContext.blogPosts.length > 0) {
    await reportProgress(`Found ${siteElementContext.blogPosts.length} blog post${siteElementContext.blogPosts.length > 1 ? 's' : ''}`, 19, 'extracting-context');
  }
  if (siteElementContext.caseStudies.length > 0) {
    await reportProgress(`Found ${siteElementContext.caseStudies.length} case stud${siteElementContext.caseStudies.length > 1 ? 'ies' : 'y'}`, 20, 'extracting-context');
  }
  
  // Fetch competitor HTMLs if provided
  const competitorContexts: SiteElementContext[] = [];
  if (state.competitors.length > 0) {
    console.log(`üîç Step 1.6: Fetching HTML and extracting page elements for competitors...`);
    const competitorPromises = state.competitors.slice(0, 3).map(async (compUrl) => {
      try {
        const compHTML = await Promise.race([
          fetchHTMLForContext(compUrl),
          new Promise<string>((resolve) => setTimeout(() => resolve(''), Math.min(4000, timeLeftMs))),
        ]);
        if (compHTML) {
          const compHtmlByUrl: Record<string, string> = { [compUrl]: compHTML };
          return extractSiteElementContext(compHtmlByUrl, compUrl);
        }
      } catch (err: any) {
        log(`‚ö†Ô∏è  Failed to fetch competitor ${compUrl}: ${err?.message || 'Unknown error'}`);
      }
      return null;
    });
    
    const competitorResults = await Promise.allSettled(competitorPromises);
    for (const result of competitorResults) {
      if (result.status === 'fulfilled' && result.value) {
        competitorContexts.push(result.value);
      }
    }
  }
  
  // Update state
  state.htmlByUrl = htmlByUrl;
  state.attemptedUrls = attemptedUrls;
  state.successfulUrls = successfulUrls;
  state.failedUrls = failedUrls;
  state.siteElementContext = siteElementContext;
  state.competitorContexts = competitorContexts;
}

/**
 * Step: Content inventory
 * Extracted from lines 481-510
 */
export async function runContentInventoryStep(state: GapRunState, _timeLeftMs: number): Promise<void> {
  const reportProgress = getReportProgress(state);
  
  console.log('üìö Step 2.4: Analyzing content inventory...');
  const contentInventory = await analyzeContentInventory(state.siteElementContext || { pages: [], blogPosts: [], caseStudies: [] });
  console.log(`‚úÖ Content inventory complete:`);
  console.log(`   - Blog posts found: ${contentInventory.blogPostsFound}`);
  console.log(`   - Case studies found: ${contentInventory.caseStudiesFound}`);
  
  await reportProgress(
    `Content inventory: ${contentInventory.blogPostsFound > 0 ? 'Blog' : ''} ${contentInventory.caseStudiesFound > 0 ? 'Case studies' : ''} detected`,
    25,
    'content-inventory'
  );
  
  // Update state
  state.contentInventory = contentInventory;
}

/**
 * Step: Technical SEO
 * Extracted from lines 517-556
 */
export async function runTechnicalSeoStep(state: GapRunState, _timeLeftMs: number): Promise<void> {
  const log = getLog(state);
  const reportProgress = getReportProgress(state);
  
  // Check if already computed (idempotent)
  if (state.technicalSeoSignals) {
    log('‚úÖ Technical SEO signals already computed, skipping');
    return;
  }
  
  log('üîç Step 2.4b: Extracting technical SEO signals...');
  
  let technicalSeoSignals: TechnicalSeoSignals;
  
  try {
    technicalSeoSignals = await extractTechnicalSeoSignals(
      state.url,
      state.assessment ?? undefined,
      state.siteElementContext || { pages: [], blogPosts: [], caseStudies: [] }
    );
    log(`‚úÖ Technical SEO signals extracted:`);
    log(`   - Lighthouse Performance: ${technicalSeoSignals.lighthousePerformanceScore || 'N/A'}`);
    log(`   - Meta Tags Present: ${technicalSeoSignals.metaTagsPresent ? 'Yes' : 'No'}`);
  } catch (error: any) {
    log(`[technical_seo] Error, using fallback: ${error?.message || String(error)}`);
    console.error('[runTechnicalSeoStep] Error extracting technical SEO signals:', error);
    
    // Return safe fallback
    technicalSeoSignals = {
      notes: ['Technical SEO analysis ran in fallback mode due to an error. Limited analysis available.'],
    };
  }
  
  // Detect analytics from pages
  const htmlByUrl = state.htmlByUrl || {};
  const analyticsData = detectAnalyticsFromPages(new Map(Object.entries(htmlByUrl)));
  const analyticsTypes: string[] = [];
  if (analyticsData.googleAnalyticsDetected) analyticsTypes.push('Google Analytics');
  if (analyticsData.gtmDetected) analyticsTypes.push('GTM');
  if (analyticsData.otherAnalyticsDetected) analyticsTypes.push('Other');
  
  if (analyticsTypes.length > 0) {
    await reportProgress(`Analytics detected: ${analyticsTypes.join(', ')}`, 28, 'analytics-detection');
  }
  
  // Build data availability
  const attemptedUrls = state.attemptedUrls || [state.url];
  const successfulUrls = state.successfulUrls || [];
  const failedUrls = state.failedUrls || [];
  const contentInventory = state.contentInventory;
  
  const coverageLevel = successfulUrls.length >= 2 ? 'good' : successfulUrls.length === 1 ? 'partial' : 'minimal';
  
  const technicalSeoData = {
    lighthouseAvailable: technicalSeoSignals.lighthouseSeoScore !== undefined || technicalSeoSignals.lighthousePerformanceScore !== undefined,
    coreWebVitalsAvailable: false,
    metaTagsParsed: technicalSeoSignals.metaTagsPresent !== undefined,
    indexabilityChecked: technicalSeoSignals.indexabilityIssues !== undefined,
    websiteScoringAvailable: state.assessment?.websiteScoringAvailable !== false,
  };
  
  const blogDetected = contentInventory ? contentInventory.blogPostsFound > 0 : false;
  const caseStudiesDetected = contentInventory ? contentInventory.caseStudiesFound > 0 : false;
  const aboutPageDetected = contentInventory ? contentInventory.aboutPageDepth !== 'minimal' : false;
  const faqDetected = contentInventory ? contentInventory.faqPresent : false;
  
  let overallConfidence: 'low' | 'medium' | 'high' = 'low';
  if (coverageLevel === 'good' && (technicalSeoData.lighthouseAvailable || technicalSeoData.metaTagsParsed || blogDetected || caseStudiesDetected)) {
    overallConfidence = 'high';
  } else if (coverageLevel === 'good' || technicalSeoData.lighthouseAvailable || technicalSeoData.metaTagsParsed || blogDetected || caseStudiesDetected) {
    overallConfidence = 'medium';
  }
  
  const dataAvailability: DataAvailability = {
    siteCrawl: {
      attemptedUrls,
      successfulUrls,
      failedUrls,
      coverageLevel,
    },
    technicalSeo: technicalSeoData,
    competitors: {
      providedByUser: state.competitors.length > 0,
      autoDiscovered: false,
      competitorCount: (state.competitorContexts || []).length,
    },
    contentInventory: {
      blogDetected,
      caseStudiesDetected,
      aboutPageDetected,
      faqDetected,
    },
    analytics: analyticsData,
    insightsAvailable: state.assessment?.websiteScoringAvailable !== false && !state.assessmentError,
    overallConfidence,
  };
  
  // Update state
  state.technicalSeoSignals = technicalSeoSignals;
  state.dataAvailability = dataAvailability;
}

/**
 * Process next step in the GAP generation workflow
 * 
 * @param state - Current GapRunState
 * @param options - Options including hardTimeBudgetMs
 * @returns Updated GapRunState
 */
export async function processNextStep(
  state: GapRunState,
  options: ProcessStepOptions
): Promise<GapRunState> {
  const stepStartTime = Date.now();
  state.updatedAt = new Date().toISOString();
  
  try {
    switch (state.step) {
      case 'init':
        await runInitStep(state, options.hardTimeBudgetMs);
        state.step = 'assessment';
        break;
        
      case 'assessment':
        await runAssessmentStep(state, options.hardTimeBudgetMs);
        state.step = 'fetch_html';
        break;
        
      case 'fetch_html':
        await runFetchHtmlStep(state, options.hardTimeBudgetMs);
        state.step = 'extract_features';
        break;
        
      case 'extract_features':
        await runExtractFeaturesStep(state, options.hardTimeBudgetMs);
        state.step = 'discover_pages';
        break;
        
      case 'discover_pages':
        runDiscoverPagesStep(state);
        state.step = 'fetch_extra_pages';
        break;
        
      case 'fetch_extra_pages':
        await runFetchExtraPagesStep(state, options.hardTimeBudgetMs);
        state.step = 'content_inventory';
        break;
        
      case 'content_inventory':
        await runContentInventoryStep(state, options.hardTimeBudgetMs);
        state.step = 'technical_seo';
        break;
        
      case 'technical_seo':
        await runTechnicalSeoStep(state, options.hardTimeBudgetMs);
        state.step = 'section_website';
        break;
        
      case 'section_website':
        // TODO: Extract runSectionWebsiteStep from original function
        state.step = 'section_seo';
        break;
        
      case 'section_seo':
        // TODO: Extract runSectionSeoStep from original function
        state.step = 'section_content';
        break;
        
      case 'section_content':
        // TODO: Extract runSectionContentStep from original function
        state.step = 'section_brand';
        break;
        
      case 'section_brand':
        // TODO: Extract runSectionBrandStep from original function
        state.step = 'quick_wins';
        break;
        
      case 'quick_wins':
        // TODO: Extract runQuickWinsStep from original function
        state.step = 'strategic_initiatives';
        break;
        
      case 'strategic_initiatives':
        // TODO: Extract runStrategicInitiativesStep from original function
        state.step = 'scoring';
        break;
        
      case 'scoring':
        // TODO: Extract runScoringStep from original function
        state.step = 'executive_summary';
        break;
        
      case 'executive_summary':
        // TODO: Extract runExecutiveSummaryStep from original function
        state.step = 'assemble_plan';
        break;
        
      case 'assemble_plan':
        // TODO: Extract runAssemblePlanStep from original function
        state.step = 'done';
        break;
        
      case 'done':
        // Already done, no-op
        break;
        
      default:
        state.error = `Unknown step: ${state.step}`;
        state.step = 'done';
    }
  } catch (error: any) {
    state.error = error?.message || 'Unknown error';
    state.step = 'done';
  }
  
  const elapsed = Date.now() - stepStartTime;
  if (elapsed > options.hardTimeBudgetMs) {
    console.warn(`[processNextStep] Step ${state.step} took ${elapsed}ms, exceeding budget of ${options.hardTimeBudgetMs}ms`);
  }
  
  return state;
}

/**
 * Generate a comprehensive Growth Acceleration Plan (GAP) for a website
 * 
 * @param url - Website URL to analyze
 * @param competitors - Optional array of competitor URLs to analyze
 * @param options - Optional configuration
 * @returns Complete GrowthAccelerationPlan
 * 
 * NOTE: This function is now a wrapper around the step-based state machine.
 * For step-based execution, use processNextStep with GapRunState instead.
 */
export async function generateGrowthAccelerationPlan(
  url: string,
  competitors: string[] = [],
  options?: {
    snapshotId?: string; // Optional: use existing snapshot
    email?: string;
    preferences?: {
      focusAreas?: string[];
      timeHorizon?: 'immediate' | 'short_term' | 'medium_term' | 'long_term';
      resourceConstraints?: string;
    };
    enableDebug?: boolean; // Force debug mode even in production
    onProgress?: (finding: string, progress?: number, stage?: string) => void | Promise<void>; // Progress callback
    gapIaData?: { // Optional: Reuse GAP-IA analysis data to skip redundant work
      core?: any;
      insights?: any;
      dimensions?: any;
      summary?: any;
      breakdown?: any;
      quickWins?: any;
    };
  }
): Promise<GrowthAccelerationPlan | GrowthAccelerationPlanFallback> {
  const reportProgress = options?.onProgress || (() => {});
  
  const startTime = Date.now();
  const log = (msg: string) => {
    const elapsed = ((Date.now() - startTime) / 1000).toFixed(1);
    console.log(`[generateGAP:${url}] [${elapsed}s] ${msg}`);
  };
  
  log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
  log('üìà GENERATING GROWTH ACCELERATION PLAN (GAP)');
  log(`üìä URL: ${url}`);
  if (competitors.length > 0) {
    log(`üîç Competitors: ${competitors.length}`);
    competitors.forEach((comp, i) => log(`   ${i + 1}. ${comp}`));
  }
  log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
  
  log('Calling reportProgress: Starting GAP analysis...');
  await reportProgress('Starting GAP analysis...', 5, 'starting');
  log('reportProgress completed');

  // Step 1: Generate assessment (use snapshot mode for faster generation)
  // OR reuse GAP-IA data if provided (much faster and more consistent)
  let assessment: AssessmentResult | null = null;
  let assessmentError: Error | null = null;

  if (options?.gapIaData) {
    // Reuse GAP-IA analysis data instead of re-crawling
    log('‚úÖ Reusing GAP-IA analysis data (skipping redundant assessment)...');
    await reportProgress('Building on existing GAP-IA analysis...', 8, 'assessment');

    const iaData = options.gapIaData;
    let overallScore = iaData.summary?.overallScore || iaData.core?.overallScore || 50;
    let brandScore = iaData.dimensions?.brand?.score || iaData.core?.brand?.brandScore || 50;
    let contentScore = iaData.dimensions?.content?.score || iaData.core?.content?.contentScore || 50;
    let seoScore = iaData.dimensions?.seo?.score || iaData.core?.seo?.seoScore || 50;
    let websiteScore = iaData.dimensions?.website?.score || iaData.core?.website?.websiteScore || 50;

    // Check for maturity override (iconic brands or failed HTML extraction)
    const maturityOverride = getMaturityOverride(url, undefined); // HTML not available when reusing GAP-IA
    if (maturityOverride) {
      log(`üèÜ Applying maturity override: ${maturityOverride.reason}`);

      // Apply minimum scores (never lower than GAP-IA, only raise if needed)
      brandScore = Math.max(brandScore, maturityOverride.minScores.brand);
      contentScore = Math.max(contentScore, maturityOverride.minScores.content);
      seoScore = Math.max(seoScore, maturityOverride.minScores.seo);
      websiteScore = Math.max(websiteScore, maturityOverride.minScores.website);
      overallScore = Math.max(overallScore, maturityOverride.minScores.overall);

      log(`  Brand: ${iaData.dimensions?.brand?.score || iaData.core?.brand?.brandScore || 50} ‚Üí ${brandScore}`);
      log(`  Content: ${iaData.dimensions?.content?.score || iaData.core?.content?.contentScore || 50} ‚Üí ${contentScore}`);
      log(`  SEO: ${iaData.dimensions?.seo?.score || iaData.core?.seo?.seoScore || 50} ‚Üí ${seoScore}`);
      log(`  Website: ${iaData.dimensions?.website?.score || iaData.core?.website?.websiteScore || 50} ‚Üí ${websiteScore}`);
      log(`  Overall: ${iaData.summary?.overallScore || iaData.core?.overallScore || 50} ‚Üí ${overallScore}`);
    }

    // Build assessment from GAP-IA data (with maturity override applied)
    assessment = {
      url,
      companyName: iaData.core?.businessName || iaData.summary?.companyName,
      overallScore,
      maturityStage: iaData.summary?.maturityStage || 'Developing',
      maturityDescription: iaData.summary?.narrative || 'Based on GAP-IA analysis',
      brandScore,
      contentScore,
      websiteScore,
      seoScore,
      scorecard: {
        overallScore,
        maturityStage: iaData.summary?.maturityStage || 'Developing',
        pillars: [],
      },
      extraction: {
        url,
        company_name: iaData.core?.businessName,
        meta: {
          title: '',
          description: '',
        },
        hero_section: {
          headline_text: '',
          subheadline_text: '',
          cta_buttons: [],
          hero_image_description: '',
        },
        navigation: {
          primary_nav_items: [],
          secondary_nav_items: [],
        },
        sections: [],
        all_headings: [],
        all_ctas: [],
        trust_signals: {
          logos_visible: [],
          testimonials_visible: [],
          review_counts_visible: '',
          awards_visible: [],
        },
        value_props: [],
        content_depth_indicators: {
          feature_lists: [],
          benefit_lists: [],
          case_study_snippets: [],
          faq_present: false,
          blog_detected: false,
          case_studies_detected: false,
          about_page_depth: 'minimal',
        },
        seo_elements: {
          h1: '',
          h2_list: [],
          h3_list: [],
          schema_detected: [],
          internal_links_detected: [],
        },
        design_and_layout: {
          visual_hierarchy_notes: '',
          cta_visibility_notes: '',
          readability_notes: '',
        },
        external_profiles: {
          linkedin_raw: '',
          gbp_raw: '',
        },
      },
      competitorAnalysis: {
        competitorsIdentified: [],
        marketLandscapeOverview: [],
        positioningComparison: {
          competitorPatterns: [],
          yourPositioning: [],
          gaps: [],
        },
        competitors: [],
        messagingAndPositioningComparison: {
          valuePropositions: [],
          targetAudience: [],
          keyDifferentiators: [],
          gaps: [],
        },
        trustAndSocialProofComparison: [],
        uxAndFunnelComparison: {
          guidedOnboardingMatchingFlows: [],
          ctaClarity: [],
          stepsToEngage: [],
          profileDepth: [],
          bookingWorkflow: [],
          mobileUX: [],
          frictionPoints: [],
        },
        contentAndAuthorityComparison: {
          blogDepth: [],
          contentFreshness: [],
          educationalResources: [],
          expertPositioning: [],
          seoStructure: [],
          categoryLeadership: [],
        },
        featureSetComparison: {
          bookingTools: [],
          communicationTools: [],
          trainerVerification: [],
          guarantees: [],
          pricingVisibility: [],
          membershipOptions: [],
          appAvailability: [],
          retentionEngagementFeatures: [],
        },
        strategicOpportunities: [],
      },
      services: {
        websiteAndConversion: {
          label: 'Website & Conversion',
          description: iaData.dimensions?.website?.oneLiner || 'Assessment from GAP-IA',
          score: websiteScore,
          pillars: [],
          keyInsights: (iaData.dimensions?.website?.issues || []).map((issue: string) => ({
            issue,
            impact: 'medium' as const,
            pillar: 'conversion' as const,
          })),
          roadmap: [],
        },
        contentAndEngagement: {
          label: 'Content & Engagement',
          description: iaData.dimensions?.content?.oneLiner || 'Assessment from GAP-IA',
          score: contentScore,
          pillars: [],
          keyInsights: (iaData.dimensions?.content?.issues || []).map((issue: string) => ({
            issue,
            impact: 'medium' as const,
            pillar: 'content' as const,
          })),
          roadmap: [],
        },
        brandingAndImpact: {
          label: 'Branding & Impact',
          description: iaData.dimensions?.brand?.oneLiner || 'Assessment from GAP-IA',
          score: brandScore,
          pillars: [],
          keyInsights: (iaData.dimensions?.brand?.issues || []).map((issue: string) => ({
            issue,
            impact: 'medium' as const,
            pillar: 'brand' as const,
          })),
          roadmap: [],
        },
      },
      summary: iaData.summary?.narrative || 'Based on GAP-IA analysis',
      topStrengths: [],
      quickWins: [],
      emergingRisks: [],
      competitorTeaser: [],
      topOpportunities: [],
      copySuggestions: [],
      websiteScoringAvailable: true,
      globalRoadmap: [],
    } as AssessmentResult;
    log('‚úÖ Assessment built from GAP-IA data');
  } else {
    // Original flow: generate fresh assessment
    // Snapshot mode skips heavy operations like competitor detection/analysis
    // We'll do our own competitor analysis later if competitors are provided
    log('üîç Step 1: Running website assessment (snapshot mode for speed)...');
    await reportProgress('Running initial website assessment...', 8, 'assessment');

    // Generate assessment without timeout wrapper - let generateFullAssessment handle its own timeouts
    // If it fails, we'll build a fallback GAP plan
    try {
      assessment = await generateFullAssessment(url, {
        mode: 'snapshot', // Use snapshot mode to skip heavy operations and stay within timeout
        includeScreenshots: false, // Skip screenshots for faster generation
      });
      log('‚úÖ Assessment completed successfully');
    } catch (error: any) {
      log(`‚ö†Ô∏è  Assessment generation failed or timed out: ${error?.message || String(error)}`);
      assessmentError = error;
      // Don't throw - we'll build a fallback GAP plan instead
    }
  }
  
  // If assessment failed, build a minimal fallback assessment
  if (!assessment) {
    log('üìã Building fallback assessment from minimal data...');
    await reportProgress('Assessment incomplete - building plan from available data', 9, 'assessment');
    
    // Create minimal fallback assessment
    // We'll fetch HTML and extract basic features to build a minimal plan
    assessment = {
      url,
      companyName: undefined,
      overallScore: 50, // Conservative default score
      maturityStage: 'Developing',
      maturityDescription: 'Assessment incomplete - using conservative estimates',
      brandScore: 50,
      contentScore: 50,
      websiteScore: 50,
      scorecard: {
        overallScore: 50,
        maturityStage: 'Developing',
        pillars: [],
      },
      extraction: {
        url,
        company_name: undefined,
        meta: {
          title: '',
          description: '',
        },
        hero_section: {
          headline_text: '',
          subheadline_text: '',
          cta_buttons: [],
          hero_image_description: '',
        },
        navigation: {
          primary_nav_items: [],
          secondary_nav_items: [],
        },
        sections: [],
        all_headings: [],
        all_ctas: [],
        trust_signals: {
          logos_visible: [],
          testimonials_visible: [],
          review_counts_visible: '',
          awards_visible: [],
        },
        value_props: [],
        content_depth_indicators: {
          feature_lists: [],
          benefit_lists: [],
          case_study_snippets: [],
          faq_present: false,
        },
        seo_elements: {
          h1: '',
          h2_list: [],
          h3_list: [],
          schema_detected: [],
          internal_links_detected: [],
        },
        design_and_layout: {
          visual_hierarchy_notes: '',
          cta_visibility_notes: '',
          readability_notes: '',
        },
        external_profiles: {
          linkedin_raw: '',
          gbp_raw: '',
        },
        analyticsAnalysis: {
          ga4Detected: false,
          gtmDetected: false,
          metaPixelDetected: false,
          hotjarDetected: false,
          mixpanelOrAmplitudeDetected: false,
        },
      },
      summary: 'Assessment generation timed out or failed. Plan generated from available website data.',
      topStrengths: [],
      quickWins: [],
      emergingRisks: ['Assessment data incomplete - recommendations based on limited analysis'],
      competitorTeaser: [],
      competitorAnalysis: {
        competitorsIdentified: [],
        marketLandscapeOverview: [],
        positioningComparison: {
          competitorPatterns: [],
          yourPositioning: [],
          gaps: [],
        },
        trustAndSocialProofComparison: [],
        uxAndFunnelComparison: {
          guidedOnboardingMatchingFlows: [],
          ctaClarity: [],
          stepsToEngage: [],
          profileDepth: [],
          bookingWorkflow: [],
          mobileUX: [],
          frictionPoints: [],
        },
        contentAndAuthorityComparison: {
          blogDepth: [],
          contentFreshness: [],
          educationalResources: [],
          expertPositioning: [],
          seoStructure: [],
          categoryLeadership: [],
        },
        featureSetComparison: {
          bookingTools: [],
          communicationTools: [],
          trainerVerification: [],
          guarantees: [],
          pricingVisibility: [],
          membershipOptions: [],
          appAvailability: [],
          retentionEngagementFeatures: [],
        },
        strategicOpportunities: [],
      },
      services: {
        websiteAndConversion: {
          label: 'Website & Conversion',
          description: 'Assessment incomplete',
          score: 50,
          pillars: [],
          keyInsights: [],
          roadmap: [],
        },
        contentAndEngagement: {
          label: 'Content & Engagement',
          description: 'Assessment incomplete',
          score: 50,
          pillars: [],
          keyInsights: [],
          roadmap: [],
        },
        brandingAndImpact: {
          label: 'Branding & Impact',
          description: 'Assessment incomplete',
          score: 50,
          pillars: [],
          keyInsights: [],
          roadmap: [],
        },
      },
      copySuggestions: [],
      websiteScoringAvailable: false,
      globalRoadmap: [],
    } as AssessmentResult;
  }

  console.log(`‚úÖ Assessment complete:`);
  console.log(`   - Overall Score: ${assessment.overallScore}/100`);
  console.log(`   - Maturity Stage: ${assessment.maturityStage}`);
  console.log(`   - Brand Score: ${assessment.brandScore}/100`);
  console.log(`   - Content Score: ${assessment.contentScore}/100`);
  console.log(`   - Website Score: ${assessment.websiteScore}/100`);
  
  await reportProgress(`Initial assessment: ${assessment.overallScore}/100 overall score`, 10, 'assessment');

  // Step 1.5: Fetch HTML and extract structured context
  console.log('üìÑ Step 1.5: Fetching HTML and extracting page elements...');
  await reportProgress('Fetching website HTML and analyzing structure...', 11, 'fetching-html');
  const htmlByUrl: Record<string, string> = {};
  
  // Track site crawl data availability
  const attemptedUrls: string[] = [url];
  const successfulUrls: string[] = [];
  const failedUrls: string[] = [];
  
  // Fetch main page HTML first
  let mainPageHTML: string | null = null;
  try {
    mainPageHTML = await fetchHTMLForContext(url);
  } catch (htmlError: any) {
    log(`‚ö†Ô∏è  Failed to fetch HTML: ${htmlError?.message || 'Unknown error'}`);
    // Continue with empty HTML - we'll build a minimal plan
  }
  
  if (!mainPageHTML) {
    log('‚ö†Ô∏è  No HTML available - using minimal fallback data');
    mainPageHTML = ''; // Use empty string as fallback
  }
  htmlByUrl[url] = mainPageHTML;
  successfulUrls.push(url);
  console.log(`‚úÖ Fetched HTML for main page (${mainPageHTML.length} chars)`);
  await reportProgress(`Fetched homepage (${Math.round(mainPageHTML.length / 1000)}k chars)`, 11.5, 'fetching-html');
  
  // Step 0: Extract SiteFeatures (structured signals from website)
  // Extract from main page HTML first, will be enhanced with additional pages later
  console.log('üìä Step 0: Extracting site features from HTML...');
  await reportProgress('Extracting site features and signals...', 12, 'extracting-features');
  const input: EvaluationInput = {
    websiteUrl: url,
    pageHtml: mainPageHTML,
    competitors,
  };
  const features = extractSiteFeatures(input);
  console.log(`‚úÖ SiteFeatures extracted (${Object.keys(features).length} signal categories)`);
  
  // Report key findings
  if (features.conversions?.ctaButtonCount && features.conversions.ctaButtonCount > 0) {
    await reportProgress(`Found ${features.conversions.ctaButtonCount} call-to-action button${features.conversions.ctaButtonCount > 1 ? 's' : ''}`, 13, 'extracting-features');
  }
  if (features.content?.hasBlog) {
    await reportProgress('Blog detected - analyzing content depth...', 14, 'extracting-features');
  }
  if (features.navigation?.navItemLabels && features.navigation.navItemLabels.length > 0) {
    await reportProgress(`Analyzing ${features.navigation.navItemLabels.length} navigation item${features.navigation.navItemLabels.length > 1 ? 's' : ''}`, 15, 'extracting-features');
  }
  
  // Discover key pages from navigation and footer
  console.log('üîç Discovering key pages from navigation and footer...');
  await reportProgress('Discovering key pages from navigation...', 16, 'discovering-pages');
  const discoveredPages = discoverKeyPages(mainPageHTML, url);
  console.log(`‚úÖ Discovered ${discoveredPages.length} key page(s) to fetch`);
  if (discoveredPages.length > 0) {
    await reportProgress(`Found ${discoveredPages.length} key page${discoveredPages.length > 1 ? 's' : ''} to analyze`, 17, 'discovering-pages');
  }
  
  // Ensure we fetch critical page types: About, Services, Blog index, Case Studies, Pricing
  // This ensures comprehensive coverage even if discovery misses some
  const criticalPageTypes = [
    { pattern: /^\/(about|team|company|who-we-are)/i, type: 'about' },
    { pattern: /^\/(services|what-we-do|solutions)/i, type: 'services' },
    { pattern: /^\/(blog|insights|resources|articles)(\/|$)/i, type: 'blogIndex' },
    { pattern: /^\/(work|case-studies|portfolio|projects)(\/|$)/i, type: 'caseStudyIndex' },
    { pattern: /^\/(pricing|plans|prices)/i, type: 'pricing' },
  ];
  
  // Check if we have all critical page types, if not, try to construct URLs
  const discoveredUrls = new Set(discoveredPages);

  for (const { pattern, type } of criticalPageTypes) {
    const hasType = discoveredPages.some(pageUrl => {
      try {
        const pathname = new URL(pageUrl).pathname.toLowerCase();
        return pattern.test(pathname);
      } catch {
        return false;
      }
    });
    
    // If missing, try common URL patterns
    if (!hasType) {
      const commonPaths: Record<string, string[]> = {
        about: ['/about', '/team', '/company', '/who-we-are'],
        services: ['/services', '/what-we-do', '/solutions'],
        blogIndex: ['/blog', '/insights', '/resources', '/articles'],
        caseStudyIndex: ['/work', '/case-studies', '/portfolio', '/projects'],
        pricing: ['/pricing', '/plans', '/prices'],
      };
      
      for (const path of commonPaths[type] || []) {
        try {
          const testUrl = new URL(path, url).href;
          if (!discoveredUrls.has(testUrl)) {
            discoveredPages.push(testUrl);
            discoveredUrls.add(testUrl);
            break; // Only add one per type
          }
        } catch {
          // Skip invalid URLs
        }
      }
    }
  }
  
  // Fetch discovered pages in parallel (limit to max 1 additional page = 2 total including homepage)
  // Aggressively reduced to 1 to stay within timeout limits (60s Vercel limit)
  const pagesToFetch = discoveredPages.slice(0, 1).filter(pageUrl => pageUrl !== url && !htmlByUrl[pageUrl]);
  
  if (pagesToFetch.length > 0) {
    console.log(`üì• Fetching ${pagesToFetch.length} page(s) in parallel...`);
    // Fetch pages with individual timeouts to prevent one slow page from blocking others
    // Reduced timeout from 6s to 4s per page to stay within overall timeout
    const fetchPromises = pagesToFetch.map(async (pageUrl) => {
      attemptedUrls.push(pageUrl);
      try {
        // Add a race condition: if fetchHTMLForContext takes too long, skip it
        const pageHTML = await Promise.race([
          fetchHTMLForContext(pageUrl),
          new Promise<string>((resolve) => setTimeout(() => resolve(''), 4000)), // 4 second max per page
        ]);
        if (pageHTML) {
          htmlByUrl[pageUrl] = pageHTML;
          successfulUrls.push(pageUrl);
          console.log(`‚úÖ Fetched HTML for ${pageUrl} (${pageHTML.length} chars)`);
          return { url: pageUrl, success: true };
        } else {
          failedUrls.push(pageUrl);
          console.warn(`‚ö†Ô∏è  Failed to fetch HTML for ${pageUrl} (timeout or empty)`);
          return { url: pageUrl, success: false };
        }
      } catch (error) {
        failedUrls.push(pageUrl);
        console.warn(`‚ö†Ô∏è  Error fetching ${pageUrl}:`, error);
        return { url: pageUrl, success: false };
      }
    });
    
    // Use Promise.allSettled to continue even if some pages fail
    await Promise.allSettled(fetchPromises);
    console.log(`‚úÖ Completed fetching ${successfulUrls.length} page(s) successfully, ${failedUrls.length} failed`);
  }
  
  // Extract structured context for main site
  await reportProgress('Extracting structured content from pages...', 18, 'extracting-context');
  const siteElementContext = extractSiteElementContext(htmlByUrl, url);
  // siteContextText is formatted for prompts but currently formatted inline where needed
  console.log(`‚úÖ Extracted structured context from ${siteElementContext.pages.length} page(s)`);
  if (siteElementContext.blogPosts.length > 0) {
    console.log(`   üìù Found ${siteElementContext.blogPosts.length} blog post(s)`);
    await reportProgress(`Found ${siteElementContext.blogPosts.length} blog post${siteElementContext.blogPosts.length > 1 ? 's' : ''}`, 19, 'extracting-context');
  }
  if (siteElementContext.caseStudies.length > 0) {
    console.log(`   üìä Found ${siteElementContext.caseStudies.length} case study(ies)`);
    await reportProgress(`Found ${siteElementContext.caseStudies.length} case stud${siteElementContext.caseStudies.length > 1 ? 'ies' : 'y'}`, 20, 'extracting-context');
  }

  // Determine coverage level based on page types found
  const pageTypesFound = new Set(siteElementContext.pages.map(p => p.type));
  const keyPageTypes = ['home', 'about', 'services', 'blogIndex', 'caseStudyIndex', 'pricing'];
  const keyPagesFound = keyPageTypes.filter(type => pageTypesFound.has(type as any)).length;
  let coverageLevel: 'minimal' | 'partial' | 'good';
  if (keyPagesFound <= 1) {
    coverageLevel = 'minimal'; // Only homepage
  } else if (keyPagesFound >= 2 && keyPagesFound <= 4) {
    coverageLevel = 'partial'; // 2-4 key templates
  } else {
    coverageLevel = 'good'; // 5+ key templates
  }

  // Step 1.6: Fetch HTML and extract structured context for competitors (in parallel)
  const competitorContexts: SiteElementContext[] = [];
  if (competitors.length > 0) {
    console.log(`üîç Step 1.6: Fetching HTML and extracting page elements for ${competitors.length} competitor(s) in parallel...`);
    
    const competitorPromises = competitors.map(async (competitorUrl) => {
      try {
        const competitorHtmlByUrl: Record<string, string> = {};
        
        // Fetch competitor main page HTML with timeout
        // Reduced timeout from 6s to 4s per competitor to stay within overall timeout
        const competitorHTML = await Promise.race([
          fetchHTMLForContext(competitorUrl),
          new Promise<string>((resolve) => setTimeout(() => resolve(''), 4000)), // 4 second max per competitor
        ]);
        if (competitorHTML) {
          competitorHtmlByUrl[competitorUrl] = competitorHTML;
          console.log(`‚úÖ Fetched HTML for competitor ${competitorUrl} (${competitorHTML.length} chars)`);
          
          // Extract structured context for competitor
          const competitorContext = extractSiteElementContext(competitorHtmlByUrl, competitorUrl);
          console.log(`‚úÖ Extracted structured context from competitor ${competitorUrl} (${competitorContext.pages.length} page(s))`);
          return competitorContext;
        } else {
          console.warn(`‚ö†Ô∏è  Failed to fetch HTML for competitor: ${competitorUrl} (timeout or empty)`);
          return null;
        }
      } catch (error) {
        console.error(`‚ùå Error processing competitor ${competitorUrl}:`, error);
        return null;
      }
    });
    
    // Use Promise.allSettled to continue even if some competitors fail
    const competitorResults = await Promise.allSettled(competitorPromises);
    const validCompetitors = competitorResults
      .filter((result): result is PromiseFulfilledResult<SiteElementContext> => 
        result.status === 'fulfilled' && result.value !== null
      )
      .map(result => result.value);
    competitorContexts.push(...validCompetitors);
    
    console.log(`‚úÖ Processed ${competitorContexts.length} competitor context(s)`);
  }

  // Step 2.4: Analyze content inventory and extract technical SEO signals (needed for section analyses)
  // Wrap in timeout to prevent blocking
  console.log('üìö Step 2.4: Analyzing content inventory...');
  const contentInventory = await Promise.race([
    analyzeContentInventory(siteElementContext),
    new Promise<Awaited<ReturnType<typeof analyzeContentInventory>>>((resolve) => 
      setTimeout(() => {
        console.warn('‚ö†Ô∏è  Content inventory analysis timeout, using fallback');
        resolve({
          blogPostsFound: 0,
          blogCategories: [],
          caseStudiesFound: 0,
          aboutPageDepth: 'minimal',
          faqPresent: false,
          contentGaps: [],
          contentVolume: 'low',
          funnelStageCoverage: {
            topOfFunnel: 'weak',
            middleOfFunnel: 'weak',
            bottomOfFunnel: 'weak',
          },
          contentThemes: [],
        });
      }, SECTION_ANALYSIS_TIMEOUT)
    ),
  ]);
  console.log(`‚úÖ Content inventory complete:`);
  console.log(`   - Blog Posts: ${contentInventory.blogPostsFound}`);
  console.log(`   - Case Studies: ${contentInventory.caseStudiesFound}`);
  console.log(`   - Content Volume: ${contentInventory.contentVolume}`);
  console.log(`   - Funnel Coverage: TOFU=${contentInventory.funnelStageCoverage.topOfFunnel}, MOFU=${contentInventory.funnelStageCoverage.middleOfFunnel}, BOFU=${contentInventory.funnelStageCoverage.bottomOfFunnel}`);
  
  await reportProgress(
    `Content inventory: ${contentInventory.blogPostsFound} blog post${contentInventory.blogPostsFound !== 1 ? 's' : ''}, ${contentInventory.caseStudiesFound} case stud${contentInventory.caseStudiesFound !== 1 ? 'ies' : 'y'}`,
    25,
    'content-inventory'
  );

  console.log('üîç Step 2.4b: Extracting technical SEO signals...');
  const technicalSeoSignals = await extractTechnicalSeoSignals(url, assessment, siteElementContext);
  console.log(`‚úÖ Technical SEO signals extracted:`);
  console.log(`   - Lighthouse Performance: ${technicalSeoSignals.lighthousePerformanceScore || 'N/A'}`);
  console.log(`   - Meta Tags Present: ${technicalSeoSignals.metaTagsPresent ? 'Yes' : 'No'}`);
  console.log(`   - Has Multiple H1: ${technicalSeoSignals.hasMultipleH1 ? 'Yes' : 'No'}`);
  console.log(`   - Has Canonical Issues: ${technicalSeoSignals.hasCanonicalTagIssues ? 'Yes' : 'No'}`);
  console.log(`   - Internal Link Count: ${technicalSeoSignals.internalLinkCount ?? 'Not counted'}`);

  // Build DataAvailability object
  const technicalSeoData = {
    lighthouseAvailable: technicalSeoSignals.lighthouseSeoScore !== undefined || technicalSeoSignals.lighthousePerformanceScore !== undefined,
    coreWebVitalsAvailable: false, // Not currently extracted
    metaTagsParsed: technicalSeoSignals.metaTagsPresent !== undefined,
    indexabilityChecked: technicalSeoSignals.indexabilityIssues !== undefined,
    websiteScoringAvailable: assessment.websiteScoringAvailable !== false, // Default to true if not set (backward compatibility)
  };
  
  // Build content inventory flags deterministically from crawled URLs
  // This ensures flags are based on actual URLs we accessed, not LLM guesses
  const contentInventoryData = buildContentInventoryFromUrls(successfulUrls);

  // Detect analytics from HTML pages
  // Convert htmlByUrl Record to Map for detectAnalyticsFromPages
  const htmlByUrlMap = new Map<string, string>();
  Object.entries(htmlByUrl).forEach(([url, html]) => {
    htmlByUrlMap.set(url, html);
  });
  const analyticsData = detectAnalyticsFromPages(htmlByUrlMap);
  console.log(`‚úÖ Analytics detection:`);
  console.log(`   - Google Analytics: ${analyticsData.googleAnalyticsDetected ? 'Detected' : 'Not detected'}`);
  console.log(`   - Google Tag Manager: ${analyticsData.gtmDetected ? 'Detected' : 'Not detected'}`);
  console.log(`   - Other Analytics: ${analyticsData.otherAnalyticsDetected ? 'Detected' : 'Not detected'}`);
  
  if (analyticsData.googleAnalyticsDetected || analyticsData.gtmDetected || analyticsData.otherAnalyticsDetected) {
    const analyticsTypes = [];
    if (analyticsData.googleAnalyticsDetected) analyticsTypes.push('Google Analytics');
    if (analyticsData.gtmDetected) analyticsTypes.push('GTM');
    if (analyticsData.otherAnalyticsDetected) analyticsTypes.push('Other');
    await reportProgress(`Analytics detected: ${analyticsTypes.join(', ')}`, 28, 'analytics-detection');
  }

  // Calculate overall confidence
  let overallConfidence: 'low' | 'medium' | 'high';
  // 'low' if coverageLevel === 'minimal' OR (no technical SEO signals AND no content inventory data)
  if (coverageLevel === 'minimal' || (!technicalSeoData.lighthouseAvailable && !technicalSeoData.metaTagsParsed && !contentInventoryData.blogDetected && !contentInventoryData.caseStudiesDetected)) {
    overallConfidence = 'low';
  } else if (coverageLevel === 'partial') {
    // 'medium' if coverageLevel === 'partial'
    overallConfidence = 'medium';
  } else if (coverageLevel === 'good' && (technicalSeoData.lighthouseAvailable || technicalSeoData.metaTagsParsed || contentInventoryData.blogDetected || contentInventoryData.caseStudiesDetected)) {
    // 'high' if coverageLevel === 'good' AND at least one of technicalSeo or contentInventory is well-populated
    overallConfidence = 'high';
  } else {
    overallConfidence = 'medium';
  }

  const dataAvailability: DataAvailability = {
    siteCrawl: {
      attemptedUrls,
      successfulUrls,
      failedUrls,
      coverageLevel,
    },
    technicalSeo: technicalSeoData,
    competitors: {
      providedByUser: competitors.length > 0,
      autoDiscovered: false, // We don't auto-discover competitors currently
      competitorCount: competitorContexts.length,
    },
    contentInventory: contentInventoryData,
    analytics: analyticsData,
    insightsAvailable: assessment.websiteScoringAvailable !== false && !assessmentError,
    overallConfidence,
  };

  // Step 2: Generate section analyses (detailed breakdowns by service area)
  // Detect maturity early so we can pass it to section analyses
  const { detectMaturity } = await import('./detectMaturity');
  const detectedMaturity = features ? detectMaturity(features) : 'growing';
  console.log(`üìä Detected maturity level: ${detectedMaturity}`);
  await reportProgress(`Detected maturity: ${detectedMaturity.replace('-', ' ')}`, 30, 'maturity-detection');

  console.log('üîç Step 2: Generating section analyses...');
  await reportProgress('Analyzing website conversion and user experience...', 35, 'section-analyses');
  // Wrap section analyses in timeout protection
  const sectionAnalysisTimeout = 12000; // 12 seconds max per analysis
  
  const [_websiteConversionAnalysis, websiteSectionAnalysis, seoSectionAnalysis, contentSectionAnalysis] = await Promise.all([
    Promise.race([
      analyzeWebsiteAndConversionPerformance(assessment),
      new Promise<Awaited<ReturnType<typeof analyzeWebsiteAndConversionPerformance>>>((resolve) => 
        setTimeout(() => {
          console.warn('‚ö†Ô∏è  Website conversion analysis timeout, using fallback');
          resolve({
            conversionFunnel: {
              currentState: 'Analysis timed out',
              stages: [],
              dropOffPoints: [],
              conversionRate: {
                estimated: 'Unknown',
                factors: [],
              },
            },
            ctaAnalysis: {
              ctaCount: 0,
              ctaClarity: 'poor',
              ctaPlacement: 'poor',
              ctaCopy: 'weak',
              primaryCta: 'Not found',
              issues: [],
              recommendations: [],
            },
            userExperience: {
              navigation: 'poor',
              pageSpeed: 'poor',
              mobileExperience: 'poor',
              trustSignals: 'missing',
              frictionPoints: [],
              strengths: [],
            },
            technicalPerformance: {
              pageSpeedScore: 0,
              analyticsSetup: 'missing',
              trackingCapabilities: [],
              missingTracking: [],
              technicalIssues: [],
            },
            opportunities: [],
            priorityActions: [],
          });
        }, sectionAnalysisTimeout)
      ),
    ]),
    Promise.race([
      analyzeWebsiteAndConversion(assessment, siteElementContext, competitorContexts, dataAvailability, detectedMaturity, features),
      new Promise<Awaited<ReturnType<typeof analyzeWebsiteAndConversion>>>((resolve) =>
        setTimeout(() => {
          console.warn('‚ö†Ô∏è  Website section analysis timeout, using fallback');
          resolve({
            label: 'Website & Conversion',
            score: 0,
            grade: 'F',
            cardLevel: {
              verdict: 'Analysis incomplete due to timeout',
              summary: 'Website analysis timed out',
            },
            deepDive: {
              strengths: [],
              issues: ['Analysis incomplete due to timeout'],
              recommendations: ['Retry website analysis'],
              impactEstimate: 'Unknown',
            },
            summary: 'Analysis timed out',
            keyFindings: [],
            quickWins: [],
            deeperInitiatives: [],
          });
        }, sectionAnalysisTimeout)
      ),
    ]),
    Promise.race([
      analyzeSeoAndVisibility(assessment, siteElementContext, competitorContexts, contentInventory, technicalSeoSignals, dataAvailability, detectedMaturity),
      new Promise<Awaited<ReturnType<typeof analyzeSeoAndVisibility>>>((resolve) =>
        setTimeout(() => {
          console.warn('‚ö†Ô∏è  SEO section analysis timeout, using fallback');
          resolve({
            label: 'SEO & Visibility',
            score: 0,
            grade: 'F',
            cardLevel: {
              verdict: 'Analysis incomplete due to timeout',
              summary: 'SEO analysis timed out',
            },
            deepDive: {
              strengths: [],
              issues: ['Analysis incomplete due to timeout'],
              recommendations: ['Retry SEO analysis'],
              impactEstimate: 'Unknown',
            },
            summary: 'Analysis timed out',
            keyFindings: [],
            quickWins: [],
            deeperInitiatives: [],
          });
        }, sectionAnalysisTimeout)
      ),
    ]),
    Promise.race([
      analyzeContentAndMessaging(assessment, siteElementContext, competitorContexts, contentInventory, dataAvailability, features, detectedMaturity),
      new Promise<Awaited<ReturnType<typeof analyzeContentAndMessaging>>>((resolve) =>
        setTimeout(() => {
          console.warn('‚ö†Ô∏è  Content section analysis timeout, using fallback');
          resolve({
            label: 'Content & Thought Leadership',
            score: 0,
            grade: 'F',
            cardLevel: {
              verdict: 'Analysis incomplete due to timeout',
              summary: 'Content analysis timed out',
            },
            deepDive: {
              strengths: [],
              issues: ['Analysis incomplete due to timeout'],
              recommendations: ['Retry content analysis'],
              impactEstimate: 'Unknown',
            },
            summary: 'Analysis timed out',
            keyFindings: [],
            quickWins: [],
            deeperInitiatives: [],
          });
        }, sectionAnalysisTimeout)
      ),
    ]),
  ]);
  
  console.log('‚úÖ Section analyses complete (except Brand & Positioning)');
  
  // If website scoring failed, append a note to the Website & Conversion summary
  if (!assessment.websiteScoringAvailable) {
    const scoringNote = ' Website scoring timed out; using conservative estimated score based on other signals.';
    websiteSectionAnalysis.summary = (websiteSectionAnalysis.summary || '') + scoringNote;
  }
  
  await reportProgress('Evaluating SEO visibility and content strategy...', 50, 'section-analyses');

  // Step 2.5: Analyze competitors, market, and positioning in parallel (they are independent)
  // These are needed for Brand & Positioning analysis but don't depend on each other
  // Use aggressive timeout to prevent exceeding 60s Vercel limit
  // Make market and positioning optional - skip if competitors not provided (saves ~24s)
  console.log('üîç Step 2.5: Analyzing competitors, market, and positioning in parallel (with timeout protection)...');
  const companyName = assessment.companyName || 'Unknown Company';
  
  // Only run market/positioning if competitors provided (they add value with competitor context)
  // Otherwise skip to save time (~24 seconds saved)
  const shouldRunMarketPositioning = competitorContexts.length > 0;
  
  // Wrap each analysis in a timeout to prevent any single call from blocking
  const analysisTimeout = 10000; // 10 seconds max per analysis (reduced from 12s)
  
  const competitorAnalysisPromise = competitorContexts.length > 0
    ? Promise.race([
        analyzeCompetitors(companyName, url, siteElementContext, competitorContexts, dataAvailability),
        new Promise<never>((_, reject) => 
          setTimeout(() => reject(new Error('Competitor analysis timeout')), analysisTimeout)
        ),
      ])
    : Promise.resolve(undefined);
  
  // Only run market/positioning if competitors provided
  const marketAnalysisPromise = shouldRunMarketPositioning
    ? Promise.race([
        analyzeMarket(companyName, competitorContexts, siteElementContext, dataAvailability),
        new Promise<never>((_, reject) => 
          setTimeout(() => reject(new Error('Market analysis timeout')), analysisTimeout)
        ),
      ])
    : Promise.resolve({
        category: 'Not evaluated (no competitors provided).',
        commonPainPoints: [],
        commonClaims: [],
        pricingPatterns: [],
        ICPProfiles: [],
        categoryTrends: [],
        differentiationWhitespace: [],
      });
  
  const positioningAnalysisPromise = shouldRunMarketPositioning
    ? Promise.race([
        analyzePositioning(companyName, siteElementContext, competitorContexts, dataAvailability),
        new Promise<never>((_, reject) => 
          setTimeout(() => reject(new Error('Positioning analysis timeout')), analysisTimeout)
        ),
      ])
    : Promise.resolve({
        primaryAudience: 'Not evaluated (no competitors provided).',
        geographicFocus: 'Not evaluated',
        corePositioningStatement: 'Not evaluated (no competitors provided).',
        keyThemes: [],
        differentiationSignals: [],
        evidenceFromSite: [],
      });
  
  const [marketAnalysisResult, competitorAnalysisResult, positioningAnalysisResult] = await Promise.allSettled([
    marketAnalysisPromise,
    competitorAnalysisPromise,
    positioningAnalysisPromise,
  ]);
  
  // Process market analysis
  let marketAnalysis: Awaited<ReturnType<typeof analyzeMarket>>;
  if (marketAnalysisResult.status === 'fulfilled') {
    marketAnalysis = marketAnalysisResult.value;
    // Sanitize marketAnalysis to ensure no error language reaches users
    const sanitizedCategory = marketAnalysis.category.toLowerCase().includes('error') || marketAnalysis.category.toLowerCase().includes('unavailable due to')
      ? 'Not evaluated (no market data available).'
      : marketAnalysis.category;
    
    marketAnalysis = {
      ...marketAnalysis,
      category: sanitizedCategory,
    };
  } else {
    console.warn('‚ö†Ô∏è  Market analysis failed:', marketAnalysisResult.reason);
    // Fallback market analysis
    marketAnalysis = {
      category: 'Not evaluated (analysis unavailable).',
      commonPainPoints: [],
      commonClaims: [],
      pricingPatterns: [],
      ICPProfiles: [],
      categoryTrends: [],
      differentiationWhitespace: [],
    };
  }
  
  // Process competitor analysis
  let competitorAnalysis: Awaited<ReturnType<typeof analyzeCompetitors>> | undefined;
  if (competitorAnalysisResult.status === 'fulfilled' && competitorAnalysisResult.value) {
    competitorAnalysis = competitorAnalysisResult.value;
    console.log(`‚úÖ Competitor analysis complete (${competitorAnalysis.competitorsReviewed.length} competitor(s) reviewed)`);
    await reportProgress(`Analyzed ${competitorAnalysis.competitorsReviewed.length} competitor${competitorAnalysis.competitorsReviewed.length > 1 ? 's' : ''}`, 45, 'competitor-analysis');
  } else if (competitorAnalysisResult.status === 'rejected') {
    console.warn('‚ö†Ô∏è  Competitor analysis failed:', competitorAnalysisResult.reason);
  }
  
  // Process positioning analysis
  let positioningAnalysis: Awaited<ReturnType<typeof analyzePositioning>>;
  if (positioningAnalysisResult.status === 'fulfilled') {
    positioningAnalysis = positioningAnalysisResult.value;
    console.log(`‚úÖ Positioning analysis complete:`);
    console.log(`   - Primary Audience: ${positioningAnalysis.primaryAudience}`);
    console.log(`   - Geographic Focus: ${positioningAnalysis.geographicFocus}`);
    console.log(`   - Key Themes: ${positioningAnalysis.keyThemes.slice(0, 3).join(', ')}`);
    await reportProgress(`Positioning: ${positioningAnalysis.primaryAudience.substring(0, 50)}...`, 47, 'positioning-analysis');
  } else {
    console.warn('‚ö†Ô∏è  Positioning analysis failed:', positioningAnalysisResult.reason);
    // Fallback positioning analysis
    positioningAnalysis = {
      primaryAudience: 'Not evaluated (analysis unavailable).',
      geographicFocus: 'Not evaluated',
      corePositioningStatement: 'Not evaluated (analysis unavailable).',
      keyThemes: [],
      differentiationSignals: [],
      evidenceFromSite: [],
    };
  }

  // Step 2.6: Generate Brand & Positioning analysis (after competitor/market/positioning analysis for strategic context)
  // Wrap in timeout to prevent blocking
  console.log('üîç Step 2.6: Analyzing Brand & Positioning (strategic focus)...');
  const brandSectionAnalysis = await Promise.race([
    analyzeBrandAndPositioning(
      assessment,
      siteElementContext,
      competitorContexts,
      competitorAnalysis,
      marketAnalysis,
      positioningAnalysis,
      dataAvailability,
      detectedMaturity
    ),
    new Promise<Awaited<ReturnType<typeof analyzeBrandAndPositioning>>>((resolve) =>
      setTimeout(() => {
        console.warn('‚ö†Ô∏è  Brand & Positioning analysis timeout, using fallback');
        resolve({
          label: 'Brand & Positioning',
          score: 0,
          grade: 'F',
          cardLevel: {
            verdict: 'Analysis incomplete due to timeout',
            summary: 'Brand analysis timed out',
          },
          deepDive: {
            strengths: [],
            issues: ['Analysis incomplete due to timeout'],
            recommendations: ['Retry brand analysis'],
            impactEstimate: 'Unknown',
          },
          summary: 'Brand and positioning analysis timed out. Analysis based on available data.',
          keyFindings: ['Analysis incomplete due to timeout'],
          quickWins: [],
          deeperInitiatives: [],
        });
      }, SECTION_ANALYSIS_TIMEOUT)
    ),
  ]);
  console.log('‚úÖ Brand & Positioning analysis complete');
  await reportProgress('Analyzing brand positioning and differentiation...', 55, 'brand-analysis');

  // Step 3: Identify quick wins (30-day actions)
  // OPTIMIZATION: Derive directly from section analyses instead of making separate OpenAI calls
  console.log('‚ö° Step 3: Deriving quick wins from section analyses...');
  await reportProgress('Identifying quick wins and immediate opportunities...', 60, 'quick-wins');

  const quickWins: QuickWin[] = [];
  let qwIndex = 1;

  // Collect recommendations from all section analyses - these are already high-quality
  const allSectionAnalyses = [
    { analysis: websiteSectionAnalysis, area: 'website' as const },
    { analysis: seoSectionAnalysis, area: 'seo' as const },
    { analysis: contentSectionAnalysis, area: 'content' as const },
    { analysis: brandSectionAnalysis, area: 'brand' as const },
  ];

  for (const { analysis, area } of allSectionAnalyses) {
    // Get recommendations from deepDive (preferred) or legacy field
    const recommendations = analysis.deepDive?.recommendations || analysis.recommendations || [];

    console.log(`[Quick Wins] ${area} analysis:`, {
      hasDeepDive: !!analysis.deepDive,
      hasRecommendations: !!analysis.deepDive?.recommendations,
      recommendationsCount: recommendations.length,
      recommendations: recommendations.slice(0, 3), // Log first 3 for debugging
    });

    // Take first 1-2 recommendations from each area as quick wins
    const quickWinRecommendations = recommendations.slice(0, 2);

    for (const rec of quickWinRecommendations) {
      // Map area to correct serviceArea enum value from schema
      const serviceAreaMap = {
        website: 'websiteAndConversion' as const,
        seo: 'seoAndVisibility' as const,
        content: 'contentAndEngagement' as const,
        brand: 'brandingAndImpact' as const,
      };

      quickWins.push({
        id: `qw-${area}-${qwIndex}`,
        title: rec.substring(0, 60), // Truncate to reasonable title length
        description: rec,
        impact: 'high' as const,
        priority: 'high' as const,
        timeHorizon: 'immediate' as const,
        resourceRequirement: 'minimal' as const,
        specificChanges: [rec],
        expectedOutcome: `Improved ${analysis.label} performance`,
        successMetrics: ['Measurable improvement in user engagement', 'Increased conversion rates'],
        estimatedEffort: '1-2 weeks',
        serviceArea: serviceAreaMap[area],
        quickWinReason: `High-priority action identified in ${analysis.label} analysis`,
        expectedTimeline: 'Within 30 days',
      });
      qwIndex++;
    }
  }

  console.log(`‚úÖ Derived ${quickWins.length} quick wins from section analyses`);
  await reportProgress(`Identified ${quickWins.length} quick win${quickWins.length > 1 ? 's' : ''}`, 62, 'quick-wins');

  // Step 4: Generate strategic initiatives (90-day+ actions)
  // OPTIMIZATION: Derive from remaining section recommendations (longer-term actions)
  console.log('üéØ Step 4: Deriving strategic initiatives from section analyses...');
  await reportProgress('Generating strategic initiatives and long-term roadmap...', 70, 'strategic-initiatives');

  const strategicInitiatives: StrategicInitiative[] = [];
  let siIndex = 1;

  // Use remaining recommendations (after quick wins) as strategic initiatives
  for (const { analysis, area } of allSectionAnalyses) {
    const recommendations = analysis.deepDive?.recommendations || analysis.recommendations || [];

    console.log(`[Strategic Initiatives] ${area} analysis:`, {
      recommendationsCount: recommendations.length,
      strategicRecommendationsCount: recommendations.slice(2, 4).length,
    });

    // Skip first 2 (used for quick wins), take next 1-2 as strategic initiatives
    const strategicRecommendations = recommendations.slice(2, 4);

    for (const rec of strategicRecommendations) {
      // Map area to correct serviceArea enum value from schema
      const serviceAreaMap = {
        website: 'websiteAndConversion' as const,
        seo: 'seoAndVisibility' as const,
        content: 'contentAndEngagement' as const,
        brand: 'brandingAndImpact' as const,
      };

      strategicInitiatives.push({
        id: `si-${area}-${siIndex}`,
        title: rec.substring(0, 60),
        description: rec,
        impact: 'high' as const,
        priority: 'medium' as const,
        timeHorizon: 'medium_term' as const,
        resourceRequirement: 'moderate' as const,
        specificChanges: [rec],
        expectedOutcome: `Significant improvement in ${analysis.label}`,
        successMetrics: [
          'Measurable improvement in performance metrics',
          'Enhanced user experience',
          'Increased conversion rates'
        ],
        estimatedEffort: '90-180 days',
        serviceArea: serviceAreaMap[area],
        totalDuration: '90-180 days',
        investmentLevel: 'medium' as const,
      });
      siIndex++;
    }
  }

  console.log(`‚úÖ Derived ${strategicInitiatives.length} strategic initiatives from section analyses`);
  await reportProgress(`Generated ${strategicInitiatives.length} strategic initiative${strategicInitiatives.length > 1 ? 's' : ''}`, 72, 'strategic-initiatives');

  // Step 5: Generate executive summary (after all sections are computed)
  console.log('üìã Step 5: Generating executive summary...');
  
  // Build dimension scores using the new scoring module
  console.log('üìä Building dimension scores from component data...');
  const dimensions = buildDimensionScores(
    features,
    siteElementContext,
    contentInventory,
    technicalSeoSignals,
    positioningAnalysis,
    assessment,
    dataAvailability
  );
  
  // Calculate scores using the new scoring module
  const scoringResult = scoreAll(dimensions);
  
  // Apply score floors for strong signals (content, authority, brand)
  const adjustedScores = applyScoreFloors(
    scoringResult.dimensionScores,
    features,
    siteElementContext,
    contentInventory,
    assessment
  );
  
  // Update scoring result with adjusted scores
  const finalScoringResult = {
    overallScore: Math.round(
      (adjustedScores.websiteAndConversion ?? 0) * 0.25 +
      (adjustedScores.contentDepthAndVelocity ?? 0) * 0.25 +
      (adjustedScores.seoAndVisibility ?? 0) * 0.25 +
      (adjustedScores.brandAndPositioning ?? 0) * 0.15 +
      (adjustedScores.authorityAndTrust ?? 0) * 0.10
    ),
    dimensionScores: adjustedScores,
  };
  
  // Build evaluatedDimensions based on data availability
  const evaluatedDimensions: ('website' | 'content' | 'seo' | 'brand' | 'authority')[] = [];
  
  // Always include website if we have site context
  if (dataAvailability.siteCrawl.successfulUrls.length > 0) {
    evaluatedDimensions.push('website');
  }
  
  // Include content if we have content inventory or site context
  if (dataAvailability.contentInventory.blogDetected || dataAvailability.contentInventory.caseStudiesDetected || dataAvailability.siteCrawl.successfulUrls.length > 0) {
    evaluatedDimensions.push('content');
  }
  
  // Include SEO if we have technical SEO signals
  if (dataAvailability.technicalSeo.lighthouseAvailable || dataAvailability.technicalSeo.metaTagsParsed) {
    evaluatedDimensions.push('seo');
  }
  
  // Always include brand (we always have some site context)
  evaluatedDimensions.push('brand');
  
  // Always include authority (we can always check trust signals)
  evaluatedDimensions.push('authority');
  
  // Extract dimension scores from final scoring result (with floors applied)
  const websiteScore = dataAvailability.siteCrawl.successfulUrls.length > 0 
    ? finalScoringResult.dimensionScores.websiteAndConversion 
    : undefined;
  const contentScore = (dataAvailability.contentInventory.blogDetected || dataAvailability.contentInventory.caseStudiesDetected || dataAvailability.siteCrawl.successfulUrls.length > 0)
    ? finalScoringResult.dimensionScores.contentDepthAndVelocity
    : undefined;
  const seoScore = (dataAvailability.technicalSeo.lighthouseAvailable || dataAvailability.technicalSeo.metaTagsParsed)
    ? finalScoringResult.dimensionScores.seoAndVisibility
    : undefined;
  const brandScore = finalScoringResult.dimensionScores.brandAndPositioning;
  const authorityScore = finalScoringResult.dimensionScores.authorityAndTrust;
  
  // Build scorecard with normalized dimension scores (0-100 each, all integers)
  const scorecard: Scorecard = {
    overall: finalScoringResult.overallScore,
    website: websiteScore,
    content: contentScore,
    seo: seoScore,
    brand: brandScore,
    authority: authorityScore,
    evaluatedDimensions,
  };
  
  console.log(`‚úÖ Scoring complete:`);
  await reportProgress(`Calculated GAP scores: Website ${scorecard.website}/100, Content ${scorecard.content}/100, SEO ${scorecard.seo}/100`, 65, 'scoring');
  console.log(`   - Overall Score: ${scorecard.overall}/100`);
  console.log(`   - Website & Conversion: ${websiteScore ?? 'Not evaluated'}/100`);
  console.log(`   - Content Depth & Velocity: ${contentScore ?? 'Not evaluated'}/100`);
  console.log(`   - SEO & Visibility: ${seoScore ?? 'Not evaluated'}/100`);
  console.log(`   - Brand & Positioning: ${brandScore}/100`);
  console.log(`   - Authority & Trust: ${authorityScore}/100`);
  
  // Debug: Log all five dimension scores
  console.info(`üìä All Dimension Scores:`, {
    website: websiteScore,
    content: contentScore,
    seo: seoScore,
    brand: brandScore,
    authority: authorityScore,
    overall: scorecard.overall,
  });
  
  // Combine quick wins and strategic initiatives as top opportunities
  const topOpportunities: Opportunity[] = [...quickWins, ...strategicInitiatives];
  
  // Step 5: Generate executive summary (after all analyses are complete)
  // Wrap in timeout to prevent blocking
  console.log('üìù Step 5: Generating executive summary...');
  const executiveSummaryResult = await Promise.race([
    generateExecutiveSummary({
    companyName: assessment.companyName || 'Unknown Company',
    websiteUrl: url,
    scorecard,
    sectionAnalyses: {
      websiteAndConversion: websiteSectionAnalysis,
      seoAndVisibility: seoSectionAnalysis,
      contentAndMessaging: contentSectionAnalysis,
      brandAndPositioning: brandSectionAnalysis,
    },
    marketAnalysis,
    positioningAnalysis,
    dataAvailability,
    contentInventory,
    technicalSeoSignals,
    competitorAnalysis: competitorAnalysis ? {
      categorySummary: competitorAnalysis.categorySummary,
      positioningPatterns: competitorAnalysis.positioningPatterns,
      messagingComparison: competitorAnalysis.messagingComparison,
      differentiationOpportunities: competitorAnalysis.differentiationOpportunities,
    } : undefined,
    topOpportunities,
    features, // Pass SiteFeatures for authority signals
  }),
    new Promise<GenerateExecutiveSummaryResult>((resolve) => 
      setTimeout(() => {
        console.warn('‚ö†Ô∏è  Executive summary generation timeout, using fallback');
        const fallbackSummary: ExecutiveSummary = {
          overallScore: scorecard.overall,
          maturityStage: assessment.maturityStage || 'Growing',
          narrative: `Growth Acceleration Plan (GAP) for ${assessment.companyName || 'this website'}. Analysis based on available data.`,
          strengths: ['Analysis based on available data'],
          keyIssues: ['Analysis incomplete due to timeout'],
          strategicPriorities: ['Complete full analysis when available'],
          expectedOutcomes: ['Improved marketing performance and growth acceleration.'],
        };
        resolve({
          executiveSummary: fallbackSummary,
          fullGap: {
            gapId: `GAP-${Date.now()}`,
            companyName: assessment.companyName || 'Unknown Company',
            websiteUrl: url,
            generatedAt: new Date().toISOString(),
            executiveSummary: {
              overallScore: scorecard.overall || 0,
              maturityStage: assessment.maturityStage || 'Growing',
              narrative: fallbackSummary.narrative,
              strengths: fallbackSummary.strengths,
              keyIssues: fallbackSummary.keyIssues,
              strategicPriorities: fallbackSummary.strategicPriorities,
            },
            scorecard: {
              brandScore: scorecard.brand || 0,
              contentScore: scorecard.content || 0,
              seoScore: scorecard.seo || 0,
              websiteScore: scorecard.website || 0,
              overallScore: scorecard.overall || 0,
            },
            sectionAnalyses: {},
            accelerators: [],
            roadmap: { now: [], next: [], later: [] },
            expectedOutcomes: fallbackSummary.expectedOutcomes,
          },
        });
      }, SECTION_ANALYSIS_TIMEOUT)
    ),
  ]);
  const executiveSummary = executiveSummaryResult.executiveSummary;
  console.log('‚úÖ Executive summary complete');
  await reportProgress('Generating executive summary and key insights...', 75, 'executive-summary');

  // Step 6: Organize into focus areas
  console.log('üóÇÔ∏è  Step 6: Organizing into focus areas...');
  const focusAreas = generateFocusAreas(assessment, quickWins, strategicInitiatives);

  // Step 7: Identify resource requirements
  console.log('üíº Step 7: Identifying resource requirements...');
  const resourceRequirements = generateResourceRequirements(assessment, quickWins, strategicInitiatives);

  // Step 8: Build timeline
  console.log('üìÖ Step 8: Building timeline...');
  const timeline = buildTimeline(quickWins, strategicInitiatives);

  // Step 9: Calculate expected outcomes
  console.log('üìä Step 9: Calculating expected outcomes...');
  const expectedOutcomes = calculateExpectedOutcomes(assessment, quickWins, strategicInitiatives, dataAvailability);

  // Step 10: Identify risks and mitigations
  console.log('‚ö†Ô∏è  Step 10: Identifying risks...');
  const risks = identifyRisks(assessment, quickWins, strategicInitiatives);

  // Step 11: Generate next steps
  console.log('üöÄ Step 11: Generating next steps...');
  const nextSteps = generateNextSteps(quickWins, strategicInitiatives);

  // Generate GAP ID
  const gapId = `GAP-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;

  // Build debug payload (dev mode or explicitly enabled)
  const isDev = process.env.NODE_ENV !== 'production';
  const shouldIncludeDebug = isDev || options?.enableDebug === true;
  let debug: GAPDebug | undefined;
  
  if (shouldIncludeDebug) {
    // Capture rubric scores BEFORE floors (raw component-based scores)
    // For brand, we need to capture the raw score before brand floors are applied
    const rawBrandScore = scoreBrandFromSignals({
      siteElementContext,
      positioningAnalysis,
      assessment,
      contentInventory,
    });
    
    const rubricDimensions = dimensions.map(dim => ({
      name: dim.name,
      weight: dim.weight,
      components: dim.components.map(c => ({
        name: c.name,
        score: c.name === 'brandScore' ? rawBrandScore : c.score, // Use raw brand score for debug
        max: c.max,
      })),
      score: scoreDimension(dim.components),
    }));

    debug = {
      features: {
        siteFeatures: features, // Include SiteFeatures in debug payload
        siteElementContext: {
          pages: siteElementContext.pages.map(page => ({
            pageUrl: page.pageUrl,
            type: page.type,
            title: page.title,
            headings: page.headings,
            navItems: page.navItems,
            ctaLabels: page.ctaLabels,
            sectionTitles: page.sectionTitles,
          })),
        },
        contentInventory,
        technicalSeoSignals,
        positioningAnalysis,
        assessment: {
          overallScore: assessment.overallScore,
          maturityStage: assessment.maturityStage,
          brandScore: assessment.brandScore,
          contentScore: assessment.contentScore,
          websiteScore: assessment.websiteScore,
        },
        dataAvailability,
      },
      rubricScores: {
        dimensions: rubricDimensions,
        overallScore: scoringResult.overallScore,
        // Include raw dimension scores before floors
        rawDimensionScores: scoringResult.dimensionScores,
        // Include raw brand score before brand floors
        rawBrandScore: rawBrandScore,
      },
      finalScores: {
        overall: scorecard.overall ?? 0,
        website: scorecard.website,
        content: scorecard.content,
        seo: scorecard.seo,
        brand: scorecard.brand,
        authority: scorecard.authority,
        evaluatedDimensions: scorecard.evaluatedDimensions,
        // Include adjusted dimension scores after floors
        adjustedDimensionScores: finalScoringResult.dimensionScores,
        // Include brand score after brand floors
        brandAfterFloors: scorecard.brand,
      },
    };
  }

  // Build complete Growth Acceleration Plan (GAP)
  const planData = {
    gapId,
    companyName: assessment.companyName || 'Unknown Company',
    websiteUrl: url,
    generatedAt: new Date().toISOString(),
    assessmentSnapshotId: options?.snapshotId,
    executiveSummary,
    quickWins,
    strategicInitiatives,
    focusAreas,
    resourceRequirements,
    timeline,
    expectedOutcomes,
    risks,
    nextSteps,
    sectionAnalyses: {
      websiteAndConversion: websiteSectionAnalysis,
      seoAndVisibility: seoSectionAnalysis,
      contentAndMessaging: contentSectionAnalysis,
      brandAndPositioning: brandSectionAnalysis,
    },
    // Legacy format for backward compatibility
    sectionAnalysesLegacy: {
      websiteAndConversion: websiteSectionAnalysis,
      seoAndVisibility: seoSectionAnalysis,
      contentAndMessaging: contentSectionAnalysis,
      brandAndPositioning: brandSectionAnalysis,
    },
    competitorAnalysis,
    marketAnalysis: marketAnalysis ? {
      category: (marketAnalysis.category.toLowerCase().includes('error') || marketAnalysis.category.toLowerCase().includes('unavailable due to'))
        ? 'Not evaluated (no market data available).'
        : marketAnalysis.category,
      commonPainPoints: marketAnalysis.commonPainPoints,
      commonClaims: marketAnalysis.commonClaims,
      pricingPatterns: marketAnalysis.pricingPatterns,
      ICPProfiles: marketAnalysis.ICPProfiles,
      categoryTrends: marketAnalysis.categoryTrends,
      differentiationWhitespace: marketAnalysis.differentiationWhitespace,
    } : {
      category: 'Not evaluated (no market data available).',
      commonPainPoints: [],
      commonClaims: [],
      pricingPatterns: [],
      ICPProfiles: [],
      categoryTrends: [],
      differentiationWhitespace: [],
    },
    positioningAnalysis,
    dataAvailability,
    scorecard,
    // Extract and include socialSignals from features
    socialSignals: features.social ? {
      hasLinkedIn: features.social.hasLinkedIn,
      hasFacebook: features.social.hasFacebook,
      hasInstagram: features.social.hasInstagram,
      linkedinUrls: features.social.linkedinUrls || [],
      facebookUrls: features.social.facebookUrls || [],
      instagramUrls: features.social.instagramUrls || [],
      // Strength levels can be computed later if needed
    } : undefined,
    ...(debug && { debug }), // Only include debug in dev mode
  };
  
  // Validate the plan against schema
  let plan = validateGrowthAccelerationPlan(planData, {
    gapId,
    companyName: assessment.companyName || 'Unknown Company',
    websiteUrl: url,
    generatedAt: new Date().toISOString(),
  });
  
  // Check if validation returned a fallback error object
  if ('error' in plan) {
    console.error('‚ùå Growth Acceleration Plan (GAP) validation failed - returning fallback error object');
    console.error('Validation errors:', plan.error.validationErrors);
  } else {
    // Migrate sectionAnalyses to new format if needed
    const { migrateSectionAnalyses } = await import('./migrateSectionAnalyses');
    // @ts-expect-error - Type incompatibility during migration, but runtime works correctly
    plan = migrateSectionAnalyses(plan);

    // Apply fallback to ensure sectionAnalyses is populated
    const { withSectionAnalysesFallback } = await import('./deriveSectionAnalysesFallback');
    // @ts-expect-error - Type incompatibility during fallback, but runtime works correctly
    plan = withSectionAnalysesFallback(plan);
  }
  
  console.log('‚úÖ Growth Acceleration Plan (GAP) generated successfully');
  console.log(`   - GAP ID: ${gapId}`);
  console.log(`   - Quick Wins: ${quickWins.length}`);
  console.log(`   - Strategic Initiatives: ${strategicInitiatives.length}`);
  console.log(`   - Focus Areas: ${focusAreas.length}`);

  // Apply score calibration for enterprise brands
  const domain = new URL(url).hostname.toLowerCase().replace(/^www\./, '');
  const calibrationResult = plan.scorecard
    ? calibrateScores(domain, plan.scorecard)
    : { calibrated: false, scores: {}, reason: 'No scorecard available' };

  if (calibrationResult.calibrated) {
    console.log(`\nüéØ Score Calibration Applied`);
    console.log(`   Reason: ${calibrationResult.reason}`);
    console.log(`   Raw scores before calibration:`, plan.scorecard);
    console.log(`   Calibrated scores:`, calibrationResult.scores);

    // Store raw scores before calibration
    (plan as any).rawScoresBeforeCalibration = { ...plan.scorecard };

    // Apply calibrated scores
    plan.scorecard = calibrationResult.scores as any;

    // Mark that calibration was applied
    (plan as any).calibrationApplied = true;
    (plan as any).calibrationReason = calibrationResult.reason;
  } else {
    (plan as any).calibrationApplied = false;
  }

  await reportProgress(
    `GAP complete: ${quickWins.length} quick win${quickWins.length !== 1 ? 's' : ''}, ${strategicInitiatives.length} strategic initiative${strategicInitiatives.length !== 1 ? 's' : ''}`,
    95,
    'finalizing'
  );

  return plan as GrowthAccelerationPlan | GrowthAccelerationPlanFallback;
}

/**
 * Analyze website and conversion performance
 * 
 * Analyzes conversion funnels, CTA effectiveness, user experience,
 * technical performance, and identifies conversion optimization opportunities.
 * 
 * @param assessment - Complete assessment result
 * @returns Website and conversion performance analysis
 */
export interface WebsiteConversionAnalysis {
  // Conversion funnel analysis
  conversionFunnel: {
    currentState: string; // Description of current funnel
    stages: Array<{
      stage: string; // e.g., "Awareness", "Consideration", "Decision", "Action"
      performance: 'excellent' | 'good' | 'needs_improvement' | 'critical';
      issues: string[];
      opportunities: string[];
    }>;
    dropOffPoints: string[]; // Where users are dropping off
    conversionRate: {
      estimated: string; // e.g., "Low (1-2%)", "Moderate (3-5%)", "High (5%+)"
      factors: string[]; // Factors affecting conversion rate
    };
  };

  // CTA analysis
  ctaAnalysis: {
    ctaCount: number;
    ctaClarity: 'excellent' | 'good' | 'needs_improvement' | 'poor';
    ctaPlacement: 'optimal' | 'good' | 'needs_improvement' | 'poor';
    ctaCopy: 'compelling' | 'clear' | 'generic' | 'weak';
    primaryCta: string; // Main CTA text
    issues: string[]; // CTA-specific issues
    recommendations: string[]; // CTA improvement recommendations
  };

  // User experience analysis
  userExperience: {
    navigation: 'excellent' | 'good' | 'needs_improvement' | 'poor';
    pageSpeed: 'excellent' | 'good' | 'needs_improvement' | 'poor';
    mobileExperience: 'excellent' | 'good' | 'needs_improvement' | 'poor';
    trustSignals: 'strong' | 'moderate' | 'weak' | 'missing';
    frictionPoints: string[]; // UX friction points
    strengths: string[]; // UX strengths
  };

  // Technical performance
  technicalPerformance: {
    pageSpeedScore: number; // 0-100
    analyticsSetup: 'comprehensive' | 'basic' | 'minimal' | 'missing';
    trackingCapabilities: string[]; // What's being tracked
    missingTracking: string[]; // What should be tracked but isn't
    technicalIssues: string[]; // Technical problems affecting conversion
  };

  // Conversion opportunities
  opportunities: Array<{
    opportunity: string;
    impact: 'high' | 'medium' | 'low';
    effort: 'low' | 'medium' | 'high';
    potentialGain: number; // Expected score improvement (0-20)
    timeframe: string; // e.g., "1-2 weeks", "30 days"
  }>;

  // Priority actions
  priorityActions: Array<{
    action: string;
    reason: string;
    expectedImpact: string;
    effort: string;
  }>;
}

function analyzeWebsiteAndConversionPerformance(
  assessment: AssessmentResult
): WebsiteConversionAnalysis {
  // Extract website and conversion service data
  const websiteService = assessment.services.websiteAndConversion;
  const websiteScore = assessment.websiteScore;
  const extraction = assessment.extraction;

  // Analyze conversion funnel
  const conversionFunnel = {
    currentState: `Current conversion funnel shows ${websiteScore < 50 ? 'significant' : websiteScore < 70 ? 'moderate' : 'strong'} performance`,
    stages: [
      {
        stage: 'Awareness',
        performance: (websiteScore >= 70 ? 'good' : websiteScore >= 50 ? 'needs_improvement' : 'critical') as 'excellent' | 'good' | 'needs_improvement' | 'critical',
        issues: websiteService.keyInsights.filter(i => i.impact === 'high').map(i => i.issue).slice(0, 2),
        opportunities: websiteService.roadmap.filter(r => r.impact === 'high').map(r => r.action).slice(0, 2),
      },
      {
        stage: 'Consideration',
        performance: (websiteScore >= 70 ? 'good' : websiteScore >= 50 ? 'needs_improvement' : 'critical') as 'excellent' | 'good' | 'needs_improvement' | 'critical',
        issues: [],
        opportunities: [],
      },
      {
        stage: 'Decision',
        performance: (websiteScore >= 70 ? 'good' : websiteScore >= 50 ? 'needs_improvement' : 'critical') as 'excellent' | 'good' | 'needs_improvement' | 'critical',
        issues: [],
        opportunities: [],
      },
      {
        stage: 'Action',
        performance: (websiteScore >= 70 ? 'good' : websiteScore >= 50 ? 'needs_improvement' : 'critical') as 'excellent' | 'good' | 'needs_improvement' | 'critical',
        issues: [],
        opportunities: [],
      },
    ],
    dropOffPoints: websiteService.keyInsights
      .filter(i => i.pillar === 'conversion' && i.impact === 'high')
      .map(i => i.issue)
      .slice(0, 3),
    conversionRate: {
      estimated: websiteScore >= 70 ? 'High (5%+)' : websiteScore >= 50 ? 'Moderate (3-5%)' : 'Low (1-2%)',
      factors: websiteService.keyInsights
        .filter(i => i.pillar === 'conversion')
        .map(i => i.issue)
        .slice(0, 3),
    },
  };

  // Analyze CTAs
  const ctaCount = extraction.all_ctas?.length || 0;
  const ctaAnalysis = {
    ctaCount,
    ctaClarity: (ctaCount > 0 ? (websiteScore >= 70 ? 'good' : 'needs_improvement') : 'poor') as 'excellent' | 'good' | 'needs_improvement' | 'poor',
    ctaPlacement: (websiteScore >= 70 ? 'good' : 'needs_improvement') as 'optimal' | 'good' | 'needs_improvement' | 'poor',
    ctaCopy: (websiteScore >= 70 ? 'clear' : 'generic') as 'compelling' | 'clear' | 'generic' | 'weak',
    primaryCta: extraction.hero_section?.cta_buttons?.[0] || extraction.all_ctas?.[0] || 'Not found',
    issues: websiteService.keyInsights
      .filter(i => i.pillar === 'conversion' && i.issue.toLowerCase().includes('cta'))
      .map(i => i.issue)
      .slice(0, 3),
    recommendations: assessment.copySuggestions
      .filter(c => c.element === 'cta')
      .map(c => c.recommended)
      .slice(0, 3),
  };

  // Analyze user experience
  const userExperience = {
    navigation: (websiteScore >= 70 ? 'good' : 'needs_improvement') as 'excellent' | 'good' | 'needs_improvement' | 'poor',
    pageSpeed: (websiteScore >= 70 ? 'good' : 'needs_improvement') as 'excellent' | 'good' | 'needs_improvement' | 'poor', // Use website score as proxy for page speed
    mobileExperience: (websiteScore >= 70 ? 'good' : 'needs_improvement') as 'excellent' | 'good' | 'needs_improvement' | 'poor',
    trustSignals: (extraction.trust_signals?.testimonials_visible?.length > 0 || extraction.trust_signals?.review_counts_visible ? 'moderate' : 'weak') as 'strong' | 'moderate' | 'weak' | 'missing',
    frictionPoints: websiteService.keyInsights
      .filter(i => i.impact === 'high')
      .map(i => i.issue)
      .slice(0, 3),
    strengths: assessment.topStrengths.filter(s => 
      s.toLowerCase().includes('navigation') || 
      s.toLowerCase().includes('experience') ||
      s.toLowerCase().includes('conversion')
    ).slice(0, 2),
  };

  // Analyze technical performance
  const technicalPerformance = {
    pageSpeedScore: 75, // Default score (performance score not available in extraction data)
    analyticsSetup: (extraction.analyticsAnalysis?.ga4Detected ? 'basic' : 'minimal') as 'comprehensive' | 'basic' | 'minimal' | 'missing',
    trackingCapabilities: [
      extraction.analyticsAnalysis?.ga4Detected ? 'GA4' : null,
      extraction.analyticsAnalysis?.gtmDetected ? 'GTM' : null,
      extraction.analyticsAnalysis?.metaPixelDetected ? 'Meta Pixel' : null,
    ].filter(Boolean) as string[],
    missingTracking: [
      !extraction.analyticsAnalysis?.ga4Detected ? 'GA4' : null,
      !extraction.analyticsAnalysis?.hotjarDetected ? 'Heatmaps/Session Recording' : null,
      !extraction.analyticsAnalysis?.mixpanelOrAmplitudeDetected ? 'Event Tracking' : null,
    ].filter(Boolean) as string[],
    technicalIssues: websiteService.keyInsights
      .filter(i => i.pillar === 'technical_health')
      .map(i => i.issue)
      .slice(0, 3),
  };

  // Identify conversion opportunities
  const opportunities = websiteService.roadmap
    .filter(r => r.service === 'websiteAndConversion')
    .slice(0, 5)
    .map(r => ({
      opportunity: r.action,
      impact: r.impact,
      effort: (r.impact === 'high' ? 'low' : 'medium') as 'high' | 'medium' | 'low',
      potentialGain: r.potentialGain,
      timeframe: r.impact === 'high' ? '1-2 weeks' : '30 days',
    }));

  // Priority actions
  const priorityActions = websiteService.roadmap
    .filter(r => r.priority <= 3)
    .slice(0, 5)
    .map(r => ({
      action: r.action,
      reason: r.specific_changes,
      expectedImpact: `${r.potentialGain} point score improvement`,
      effort: r.impact === 'high' ? 'Low effort' : 'Moderate effort',
    }));

  return {
    conversionFunnel,
    ctaAnalysis,
    userExperience,
    technicalPerformance,
    opportunities,
    priorityActions,
  };
}

/**
 * Generate quick wins (30-day high-impact actions)
 * Uses OpenAI to generate concrete, site-specific quick wins
 */
export async function generateQuickWins(
  assessment: AssessmentResult,
  websiteConversionAnalysis: WebsiteConversionAnalysis,
  siteElementContext: SiteElementContext,
  competitorContexts: SiteElementContext[] = [],
  dataAvailability?: DataAvailability
): Promise<QuickWin[]> {
  console.log('ü§ñ Generating quick wins with AI...');

  // Extract site-specific elements from assessment
  const extraction = assessment.extraction;
  const pageElements = {
    headlines: [
      extraction.hero_section?.headline_text,
      ...(extraction.all_headings || []).slice(0, 10),
    ].filter(Boolean),
    navigationItems: [
      ...(extraction.navigation?.primary_nav_items || []),
      ...(extraction.navigation?.secondary_nav_items || []),
    ],
    ctaLabels: [
      ...(extraction.hero_section?.cta_buttons || []),
      ...(extraction.all_ctas || []),
    ].slice(0, 10),
    sectionTitles: extraction.sections?.map(s => s.heading).filter(Boolean) || [],
    valueProps: extraction.value_props || [],
  };

  // Build summary of issues and opportunities
  const issuesSummary = [
    ...assessment.services.websiteAndConversion.keyInsights
      .filter(i => i.impact === 'high')
      .slice(0, 5)
      .map(i => `${i.issue}: ${i.why_it_matters}`),
    ...assessment.services.contentAndEngagement.keyInsights
      .filter(i => i.impact === 'high')
      .slice(0, 3)
      .map(i => `${i.issue}: ${i.why_it_matters}`),
    ...assessment.services.brandingAndImpact.keyInsights
      .filter(i => i.impact === 'high')
      .slice(0, 3)
      .map(i => `${i.issue}: ${i.why_it_matters}`),
  ];

  // Score breakdown
  const scoreBreakdown = {
    website: assessment.websiteScore,
    content: assessment.contentScore,
    brand: assessment.brandScore,
    overall: assessment.overallScore,
    conversion: assessment.websiteScore, // Website score includes conversion
    seo: assessment.contentScore, // Content score includes SEO aspects
  };

  const systemPrompt = `You are a senior marketing strategist writing Quick Wins for a founder or small marketing team with limited experience.

INTRO SENTENCE REQUIREMENT:
At the top of your response JSON, include an "introSentence" field with:
"These are high-impact, lower-effort changes you can make in the next 30 days."

You will receive:
- companyName
- websiteUrl
- a list of key on-page elements (headlines, navigation labels, CTA labels, key section titles)
- a summary of issues and opportunities from other analyses (website, content, SEO, brand)
- the current score breakdown (website, content, SEO, brand, conversion)

Your job:
- Propose 3‚Äì5 improvements that can be implemented within 1‚Äì2 weeks.
- Each quick win MUST reference at least one specific element from the website (e.g. a particular headline, CTA, nav item, or page).
- Avoid generic advice such as 'improve SEO', 'add more content', or 'post on social media'.
- Do NOT use placeholder metric names like 'Metric 1'. Use real metrics a founder would understand (e.g. 'Homepage CTA click-through rate', 'Demo requests per week', 'Organic sessions to /services').

TONE & STYLE REQUIREMENTS:
- Write for relatively inexperienced marketers / founders / first-time marketing hires
- Use plain, concrete language that explains WHY each item matters
- Tie each quick win to one or more scorecard dimensions ("This directly improves Website & Conversion by giving visitors a clear next step")
- Connect every recommendation to business outcomes: more traffic, more leads, higher conversions, more trust
- Be encouraging and actionable, like coaching a founder: friendly, clear, motivating
- Avoid jargon OR explain it inline (e.g., "meta description (the preview text in Google search results)")

DESCRIPTION REQUIREMENTS:
Each description should:
- Explain WHAT needs to change (specific, concrete)
- Explain WHY it matters in business terms (impact on traffic/leads/conversions/trust)
- Reference which scorecard dimension it improves
- Use 2-3 sentences maximum

EXAMPLE:
"Update your homepage H1 (main headline) from 'Welcome' to clearly state what you offer and who it's for (e.g., 'We Help Small Businesses Grow Through Data-Driven Marketing'). This directly improves Brand & Positioning by helping visitors immediately understand your value, which reduces bounce rates and increases time on site. Takes 30 minutes and can lift homepage engagement by 15-20%."

ANALYTICS RULES:
- If any analyticsDetected flag (googleAnalyticsDetected, gtmDetected, or otherAnalyticsDetected) is true, you MUST NOT recommend 'set up Google Analytics' or 'implement analytics tracking' as a quick win.
- If analytics are detected, you may instead recommend improving event tracking, setting up conversion goals, or using existing analytics better.
- Only recommend 'set up analytics' or 'implement tracking' if NO analytics tools are detected (all analyticsDetected flags are false).

TIME HORIZON DISTRIBUTION RULES:
You MUST assign each quick win a timeHorizon with one of exactly two values:
- "immediate" ‚Äî can be started right away (0‚Äì2 weeks)
- "short_term" ‚Äî next priorities (2‚Äì8 weeks)

CRITICAL DISTRIBUTION REQUIREMENT: You MUST distribute quick wins across BOTH time horizons. Do NOT put all quick wins in "immediate".

Distribution rules:
- If generating 3 quick wins: use 2 "immediate" and 1 "short_term" (MANDATORY)
- If generating 4 quick wins: use 2 "immediate" and 2 "short_term" (MANDATORY)
- If generating 5 quick wins: use 3 "immediate" and 2 "short_term" (MANDATORY)

You MUST include at least one "short_term" quick win. Never put all quick wins in "immediate".

Return a JSON object with a "quickWins" array containing 3-5 QuickWin objects. Each QuickWin has this shape:
{
  "id": string,
  "title": string,
  "description": string,
  "priority": "low" | "medium" | "high",
  "timeHorizon": "immediate" | "short_term",
  "impact": "low" | "medium" | "high",
  "resourceRequirement": "minimal" | "moderate" | "significant",
  "specificChanges": string[],
  "expectedOutcome": string,
  "successMetrics": string[],
  "potentialScoreGain": number,
  "estimatedEffort": string,
  "serviceArea": "brandingAndImpact" | "contentAndEngagement" | "websiteAndConversion" | "cross_cutting",
  "quickWinReason": string,
  "expectedTimeline": string
}

Example response format:
{
  "quickWins": [
    {
      "id": "qw-1",
      "title": "Improve hero headline clarity",
      "description": "Change the headline from 'Welcome' to a benefit-driven message like 'Transform Your Marketing Performance'",
      ...
    }
  ]
}

Make sure the JSON is valid and does not contain placeholder text like "Metric 1" or generic phrases like "Implement improve".`;

  const siteContextText = formatSiteContextForPrompt(siteElementContext);
  const competitorContextText = competitorContexts.length > 0 ? formatCompetitorContextsForPrompt(competitorContexts) : '';

  const userPrompt = `Generate quick wins for this website:

Company: ${assessment.companyName || 'Unknown'}
Website: ${assessment.url}

Site Structure & Elements:
${siteContextText}${competitorContextText}

Current Scores:
- Overall: ${scoreBreakdown.overall}/100
- Website/Conversion: ${scoreBreakdown.website}/100
- Content/SEO: ${scoreBreakdown.content}/100
- Brand: ${scoreBreakdown.brand}/100

Key On-Page Elements:
Headlines:
${pageElements.headlines.map(h => `- ${h}`).join('\n')}

Navigation Items:
${pageElements.navigationItems.map(n => `- ${n}`).join('\n')}

CTA Labels:
${pageElements.ctaLabels.map(c => `- ${c}`).join('\n')}

Section Titles:
${pageElements.sectionTitles.map(s => `- ${s}`).join('\n')}

Value Propositions:
${pageElements.valueProps.map(v => `- ${v}`).join('\n')}

Issues and Opportunities:
${issuesSummary.map(i => `- ${i}`).join('\n')}

Website/Conversion Analysis:
- Conversion Funnel: ${websiteConversionAnalysis.conversionFunnel.currentState}
- CTA Analysis: ${websiteConversionAnalysis.ctaAnalysis.ctaCount} CTAs found, clarity: ${websiteConversionAnalysis.ctaAnalysis.ctaClarity}
- Primary CTA: "${websiteConversionAnalysis.ctaAnalysis.primaryCta}"
- UX Friction Points: ${websiteConversionAnalysis.userExperience.frictionPoints.join(', ')}
- Conversion Opportunities: ${websiteConversionAnalysis.opportunities.slice(0, 3).map(o => o.opportunity).join(', ')}

${dataAvailability ? `Analytics Summary (deterministic detection from HTML):
{
  "googleAnalyticsDetected": ${dataAvailability.analytics.googleAnalyticsDetected},
  "gtmDetected": ${dataAvailability.analytics.gtmDetected},
  "otherAnalyticsDetected": ${dataAvailability.analytics.otherAnalyticsDetected}
}

IMPORTANT: If any analyticsDetected flag is true, do NOT recommend setting up analytics. Instead, recommend improving existing analytics usage (event tracking, conversion goals, etc.).` : ''}

Generate 3-5 concrete, site-specific quick wins that reference actual elements from this website.`;

  try {
    const openai = getOpenAI();
    // Wrap OpenAI call in Promise.race with 8-second timeout (shorter than outer Promise.race's 10s)
    const completion = await Promise.race([
      openai.chat.completions.create({
        model: 'gpt-4o-mini',
        messages: [
          {
            role: 'system',
            content: systemPrompt,
          },
          {
            role: 'user',
            content: userPrompt,
          },
        ],
        temperature: 0.7,
        response_format: { type: 'json_object' },
        max_tokens: 1200, // Reduced for faster response
      }),
      new Promise<never>((_, reject) =>
        setTimeout(() => reject(new Error('OpenAI request timed out after 8 seconds')), 8000)
      ),
    ]);

    const content = completion.choices[0]?.message?.content;
    if (!content) {
      throw new Error('No content from OpenAI');
    }

    const parsed = JSON.parse(content);
    
    // Handle both { quickWins: [...] } and [...] formats
    const quickWinsArray = parsed.quickWins || parsed;
    
    if (!Array.isArray(quickWinsArray)) {
      throw new Error('Invalid response format: expected array of quick wins');
    }

    // Debug: Log raw time horizons from LLM
    console.debug('[GAP Plan] Raw quick win timings:', quickWinsArray.map((qw: any) => ({
      id: qw.id,
      title: qw.title?.substring(0, 30),
      timeHorizon: qw.timeHorizon || 'missing'
    })));

    // Filter out analytics setup recommendations if analytics are already detected
    const hasAnalytics = dataAvailability && (
      dataAvailability.analytics.googleAnalyticsDetected ||
      dataAvailability.analytics.gtmDetected ||
      dataAvailability.analytics.otherAnalyticsDetected
    );
    
    // Filter quick wins to remove analytics setup if analytics are detected
    const filteredQuickWins = hasAnalytics
      ? quickWinsArray.filter((qw: any) => {
          const titleLower = (qw.title || '').toLowerCase();
          const descLower = (qw.description || '').toLowerCase();
          return !(
            titleLower.includes('set up google analytics') ||
            titleLower.includes('implement analytics') ||
            titleLower.includes('add analytics') ||
            titleLower.includes('install analytics') ||
            descLower.includes('set up google analytics') ||
            descLower.includes('implement analytics tracking')
          );
        })
      : quickWinsArray;

    // Validate and ensure all required fields
    const validatedQuickWins: QuickWin[] = filteredQuickWins.slice(0, 5).map((qw: any, index: number) => {
      // Normalize timeHorizon - accept variants and normalize to canonical format
      const rawTimeHorizon = qw.timeHorizon;
      const normalizedTimeHorizon = normalizeTimeHorizon(rawTimeHorizon);
      
      // Ensure all required fields exist with valid values
      return {
        id: qw.id || `qw-${index + 1}`,
        title: qw.title || `Quick Win ${index + 1}`,
        description: qw.description || '',
        priority: (qw.priority === 'low' || qw.priority === 'medium' || qw.priority === 'high') ? qw.priority : 'high',
        // Normalize timeHorizon, but ensure it's either immediate or short_term for quick wins
        timeHorizon: (normalizedTimeHorizon === 'immediate' || normalizedTimeHorizon === 'short_term') 
          ? normalizedTimeHorizon 
          : 'immediate',
        impact: (qw.impact === 'low' || qw.impact === 'medium' || qw.impact === 'high') ? qw.impact : 'high',
        resourceRequirement: (qw.resourceRequirement === 'minimal' || qw.resourceRequirement === 'moderate' || qw.resourceRequirement === 'significant') ? qw.resourceRequirement : 'minimal',
        specificChanges: Array.isArray(qw.specificChanges) ? qw.specificChanges : [qw.specificChanges || ''],
        expectedOutcome: qw.expectedOutcome || '',
        successMetrics: Array.isArray(qw.successMetrics) ? qw.successMetrics.filter((m: string) => m && !m.includes('Metric 1') && !m.includes('Metric 2')) : [],
        potentialScoreGain: typeof qw.potentialScoreGain === 'number' && qw.potentialScoreGain > 0 ? qw.potentialScoreGain : undefined, // Only use if LLM provided a value
        estimatedEffort: qw.estimatedEffort || '1-2 weeks',
        serviceArea: (qw.serviceArea === 'brandingAndImpact' || qw.serviceArea === 'contentAndEngagement' || qw.serviceArea === 'websiteAndConversion' || qw.serviceArea === 'cross_cutting') ? qw.serviceArea : 'cross_cutting',
        quickWinReason: qw.quickWinReason || '',
        expectedTimeline: qw.expectedTimeline || 'Week 1-2',
      };
    });

    console.log(`‚úÖ Generated ${validatedQuickWins.length} quick wins`);
    return validatedQuickWins;
  } catch (error: any) {
    // Check if it's a timeout error - if so, return empty array (outer Promise.race will handle it)
    if (error?.message?.includes('timed out') || error?.message?.includes('Request timed out')) {
      console.warn('‚ö†Ô∏è  Quick wins generation timed out, using fallback');
      return [];
    }
    console.error('‚ùå Error generating quick wins with AI:', error);
    // Fallback to basic quick wins if AI fails
    console.log('‚ö†Ô∏è  Falling back to basic quick wins from assessment');
    return assessment.quickWins.slice(0, 3).map((win, index) => ({
      id: `qw-${index + 1}`,
      title: win,
      description: `Address ${win.toLowerCase()} based on assessment findings.`, // Generic, not site-specific
      priority: 'high' as const,
      timeHorizon: 'immediate' as const,
      impact: 'high' as const,
      resourceRequirement: 'minimal' as const,
      specificChanges: [`Review and address ${win.toLowerCase()} based on site context`], // Generic guidance
      expectedOutcome: `Improvements to ${win.toLowerCase()} based on assessment recommendations`, // Generic, not specific promise
      successMetrics: [], // Let LLM generate these based on actual context
      potentialScoreGain: undefined, // Let LLM estimate based on actual impact
      estimatedEffort: '1-2 weeks',
      serviceArea: 'cross_cutting' as const,
      quickWinReason: 'High impact with minimal resource requirement',
      expectedTimeline: 'Week 1-2',
    }));
  }
}

/**
 * Generate strategic initiatives (90-day+ comprehensive actions)
 * Uses OpenAI to generate concrete, project-sized strategic initiatives
 */
export async function generateStrategicInitiatives(
  assessment: AssessmentResult,
  websiteConversionAnalysis: WebsiteConversionAnalysis,
  quickWins: QuickWin[],
  siteElementContext: SiteElementContext,
  competitorContexts: SiteElementContext[] = [],
  competitorAnalysis?: Awaited<ReturnType<typeof analyzeCompetitors>>,
  marketAnalysis?: Awaited<ReturnType<typeof analyzeMarket>>,
  positioningAnalysis?: PositioningAnalysis,
  contentInventory?: ContentInventory
): Promise<StrategicInitiative[]> {
  console.log('ü§ñ Generating strategic initiatives with AI...');

  // Extract summaries from service analyses
  const websiteSummary = assessment.services.websiteAndConversion.keyInsights
    .slice(0, 5)
    .map(i => `${i.issue}: ${i.why_it_matters}`)
    .join('\n');

  const contentSummary = assessment.services.contentAndEngagement.keyInsights
    .slice(0, 5)
    .map(i => `${i.issue}: ${i.why_it_matters}`)
    .join('\n');

  const brandSummary = assessment.services.brandingAndImpact.keyInsights
    .slice(0, 5)
    .map(i => `${i.issue}: ${i.why_it_matters}`)
    .join('\n');

  // Score breakdown
  const scoreBreakdown = {
    website: assessment.websiteScore,
    content: assessment.contentScore,
    brand: assessment.brandScore,
    overall: assessment.overallScore,
    conversion: assessment.websiteScore,
    seo: assessment.contentScore,
  };

  // Extract key page elements for context
  const extraction = assessment.extraction;
  const keyPages = [
    extraction.url,
    ...(extraction.navigation?.primary_nav_items || []).slice(0, 5),
  ];

  const systemPrompt = `You are a senior marketing strategist planning 3‚Äì5 STRATEGIC INITIATIVES for the next 60-180 days, written for a founder or small marketing team.

INTRO SENTENCE REQUIREMENT:
At the top of your response JSON, include an "introSentence" field with:
"These are longer-term projects (60‚Äì180 days) that will fundamentally improve your marketing system."

You will receive:
- companyName
- websiteUrl
- the same score breakdown used elsewhere
- summaries of the website, SEO, content, and brand analyses
- the list of Quick Wins (which handle very fast, low-effort items)
- competitor analysis (if available): positioning patterns, messaging comparisons, differentiation opportunities, content footprint summary, SEO visibility summary
- market analysis (if available): category, ICP profiles, common claims, pricing patterns, category trends, differentiation whitespace

Your job:
- Define 3‚Äì5 larger initiatives that can be executed over 60-180 days.
- Each initiative should be clearly tied to one main service area: brandingAndImpact, contentAndEngagement, websiteAndConversion, or seoAndVisibility.
- Each initiative should be specific, not generic. Reference concrete changes when possible (e.g. 'Create a 6-article content series for [topic] targeting [audience]', 'Redesign the /services page to clarify tiers and CTAs', etc.).
- Avoid vague advice like 'improve brand' or 'do more SEO'.
- Make initiatives realistic for an early-stage company with limited but focused resources.

TONE & STYLE REQUIREMENTS:
- Write for relatively inexperienced marketers / founders / first-time marketing hires
- Use plain, concrete language that explains WHY each initiative matters
- Tie each initiative to one or more scorecard dimensions
- Connect every recommendation to business outcomes: more traffic, more leads, higher conversions, stronger authority
- Be encouraging and strategic, like coaching a founder on the big picture
- Avoid jargon OR explain it inline

DESCRIPTION REQUIREMENTS:
Each description should:
- Explain WHAT the initiative involves (specific, concrete project)
- Explain WHY it matters in business terms (impact on traffic/leads/conversions/trust/authority)
- Reference which scorecard dimension(s) it improves
- Use 2-4 sentences

EXAMPLE:
"Build a comprehensive content library with 15-20 resources (guides, templates, calculators) targeting your ideal customer's key pain points. This directly improves Content & Messaging and SEO & Visibility by establishing your authority in the space, driving organic traffic from long-tail searches, and giving sales a library of resources to share with prospects. Over 6 months, this can increase organic traffic by 200-300% and provide valuable lead magnets that convert 3-5% of visitors into qualified leads."

REQUIRED: You MUST ensure:
- At least ONE initiative addresses differentiation (how to stand out based on positioning analysis, market whitespace, or competitor patterns)
- At least ONE initiative addresses content footprint (content gaps from content inventory, content depth vs competitors, funnel coverage gaps)
- At least ONE initiative addresses authority signals (if gaps exist - e.g., testimonials, case studies, certifications, thought leadership)
- At least ONE initiative is tied to positioning/geographic focus (if positioning analysis shows hyper-local focus, initiatives should reflect that)

HYPER-LOCAL POSITIONING RULES:
- If positioningAnalysis.geographicFocus or positioningAnalysis.localSearchLanguage indicate a hyper-local or neighborhood-based model, you MUST:
  - Prefer initiatives that deepen local dominance (e.g., neighborhood-specific SEO, local content hubs, city/ZIP targeting, location-based landing pages) over generic national positioning.
  - At least ONE initiative should explicitly leverage the hyper-local positioning (e.g., "Build neighborhood-specific content hubs", "Create location-based landing pages", "Develop local SEO strategy for target neighborhoods").
  - Do NOT propose initiatives that dilute the hyper-local focus or suggest going national unless there's clear evidence that's the strategic direction.
  - Treat hyper-local positioning as a competitive advantage to be deepened, not a limitation to overcome.

If competitor/market analysis is provided:
- Reference specific competitive conditions, gaps, or opportunities
- Address ranking/intents competitors occupy (specific keywords, topics, or search intents where competitors rank but this company doesn't)

All initiatives should be positioning-aware, content-aware, and competitor-aware when relevant. Make the text specific - reference actual positioning themes, content gaps, competitor patterns, or market opportunities identified in the analyses.

TIME HORIZON DISTRIBUTION RULES:
You MUST assign each strategic initiative a timeHorizon with one of exactly two values:
- "medium_term" ‚Äî foundation or bigger changes (2‚Äì6 months)
- "long_term" ‚Äî strategic initiatives (6‚Äì18 months)

CRITICAL DISTRIBUTION REQUIREMENT: You MUST distribute strategic initiatives across BOTH time horizons. Do NOT put all initiatives in "medium_term" or "long_term".

Distribution rules:
- If generating 3 initiatives: use 2 "medium_term" and 1 "long_term" (MANDATORY)
- If generating 4 initiatives: use 2 "medium_term" and 2 "long_term" (MANDATORY)
- If generating 5 initiatives: use 3 "medium_term" and 2 "long_term" (MANDATORY)

You MUST include at least one initiative in each time horizon. Never put all initiatives in one bucket.

Return a JSON object with a "strategicInitiatives" array containing 3-5 StrategicInitiative objects. Each StrategicInitiative has this shape:
{
  "id": string,
  "title": string,
  "description": string,
  "priority": "low" | "medium" | "high",
  "timeHorizon": "medium_term" | "long_term",
  "impact": "low" | "medium" | "high",
  "resourceRequirement": "minimal" | "moderate" | "significant",
  "specificChanges": string[],
  "expectedOutcome": string,
  "successMetrics": string[],
  "potentialScoreGain": number,
  "estimatedEffort": string,
  "serviceArea": "brandingAndImpact" | "contentAndEngagement" | "websiteAndConversion" | "seoAndVisibility",
  "totalDuration": string,
  "investmentLevel": "low" | "medium" | "high",
  "expectedROI": string
}

Example response format:
{
  "strategicInitiatives": [
    {
      "id": "si-1",
      "title": "Build Authority Content Series",
      "description": "Create a 6-article content series targeting [specific topic] for [specific audience]",
      "serviceArea": "contentAndEngagement",
      ...
    }
  ]
}

Make sure the JSON is valid and all text is concrete and non-placeholder.`;

  const siteContextText = formatSiteContextForPrompt(siteElementContext);
  const competitorContextText = competitorContexts.length > 0 ? formatCompetitorContextsForPrompt(competitorContexts) : '';

  const userPrompt = `Generate strategic initiatives for this website:

Company: ${assessment.companyName || 'Unknown'}
Website: ${assessment.url}

Site Structure & Elements:
${siteContextText}${competitorContextText}

Current Scores:
- Overall: ${scoreBreakdown.overall}/100
- Website/Conversion: ${scoreBreakdown.website}/100
- Content/SEO: ${scoreBreakdown.content}/100
- Brand: ${scoreBreakdown.brand}/100

Website Analysis Summary:
${websiteSummary || 'No specific website issues identified.'}

Content & SEO Analysis Summary:
${contentSummary || 'No specific content issues identified.'}

Brand Analysis Summary:
${brandSummary || 'No specific brand issues identified.'}

Key Pages/URLs:
${keyPages.map(p => `- ${p}`).join('\n')}

Quick Wins Already Planned (these handle immediate, low-effort items):
${quickWins.map(qw => `- ${qw.title}: ${qw.description}`).join('\n') || 'None yet'}

${competitorAnalysis ? `Competitor Analysis:
- Category Summary: ${competitorAnalysis.categorySummary}
- Positioning Patterns: ${competitorAnalysis.positioningPatterns.join('; ')}
- Messaging Comparison: ${competitorAnalysis.messagingComparison.join('; ')}
- Differentiation Opportunities: ${competitorAnalysis.differentiationOpportunities.join('; ')}
- Content Footprint Summary: ${competitorAnalysis.contentFootprintSummary.join('; ')}
- SEO Visibility Summary: ${competitorAnalysis.seoVisibilitySummary.join('; ')}
` : ''}

${marketAnalysis ? `Market Analysis:
- Category: ${marketAnalysis.category.toLowerCase().includes('error') || marketAnalysis.category.toLowerCase().includes('unavailable due to') ? 'Not evaluated (no market data available).' : marketAnalysis.category}
- ICP Profiles: ${marketAnalysis.ICPProfiles.join('; ')}
- Common Claims: ${marketAnalysis.commonClaims.join('; ')}
- Common Pain Points: ${marketAnalysis.commonPainPoints.join('; ')}
- Pricing Patterns: ${marketAnalysis.pricingPatterns.join('; ')}
- Category Trends: ${marketAnalysis.categoryTrends.join('; ')}
- Differentiation Whitespace: ${marketAnalysis.differentiationWhitespace.join('; ')}
` : ''}

${positioningAnalysis ? `Positioning Analysis:
- Primary Audience: ${positioningAnalysis.primaryAudience}
- Geographic Focus: ${positioningAnalysis.geographicFocus}
${positioningAnalysis.localSearchLanguage && positioningAnalysis.localSearchLanguage.length > 0 ? `- Local Search Language: ${positioningAnalysis.localSearchLanguage.join('; ')}` : ''}
- Core Positioning Statement: ${positioningAnalysis.corePositioningStatement}
- Key Themes: ${positioningAnalysis.keyThemes.join('; ')}
- Differentiation Signals: ${positioningAnalysis.differentiationSignals.join('; ')}
${positioningAnalysis.geographicFocus.toLowerCase().includes('hyper-local') || positioningAnalysis.geographicFocus.toLowerCase().includes('neighborhood') || (positioningAnalysis.localSearchLanguage && positioningAnalysis.localSearchLanguage.length > 0) ? `
CRITICAL: This brand uses hyper-local/neighborhood-focused positioning. You MUST propose at least one initiative that deepens this local dominance (e.g., neighborhood-specific SEO, local content hubs, city/ZIP targeting). Do NOT propose generic national initiatives that would dilute this positioning.` : ''}
` : ''}

${contentInventory ? `Content Inventory:
- Blog Posts: ${contentInventory.blogPostsFound}
- Blog Categories: ${contentInventory.blogCategories.join(', ') || 'None'}
- Case Studies: ${contentInventory.caseStudiesFound}
- Content Volume: ${contentInventory.contentVolume}
- Funnel Coverage: TOFU=${contentInventory.funnelStageCoverage.topOfFunnel}, MOFU=${contentInventory.funnelStageCoverage.middleOfFunnel}, BOFU=${contentInventory.funnelStageCoverage.bottomOfFunnel}
- Content Gaps: ${contentInventory.contentGaps.join(', ') || 'None'}
` : ''}

Generate 3-5 concrete, project-sized strategic initiatives that:
- Build on the quick wins or address deeper issues
- Are specific and actionable (reference actual pages, topics, or changes)
- Are realistic for a company with focused resources
- Are distributed across different service areas (brand, content, website, SEO)
- Can be executed over ~90 days
${competitorAnalysis || marketAnalysis ? '- MUST include at least one initiative addressing differentiation, one addressing content footprint vs competitors, one addressing authority signals (if gaps exist), and one tied to ranking/intents competitors occupy' : ''}
- Reference specific competitive conditions, gaps, or opportunities when competitor/market analysis is available
- Make the text competitor-aware and specific (mention actual competitor patterns, content gaps, or ranking opportunities)`;

  try {
    const openai = getOpenAI();
    // Wrap OpenAI call in Promise.race with 8-second timeout (shorter than outer Promise.race's 10s)
    const completion = await Promise.race([
      openai.chat.completions.create({
        model: 'gpt-4o-mini',
        messages: [
          {
            role: 'system',
            content: systemPrompt,
          },
          {
            role: 'user',
            content: userPrompt,
          },
        ],
        temperature: 0.7,
        response_format: { type: 'json_object' },
        max_tokens: 1500, // Reduced for faster response
      }),
      new Promise<never>((_, reject) =>
        setTimeout(() => reject(new Error('OpenAI request timed out after 8 seconds')), 8000)
      ),
    ]);

    const content = completion.choices[0]?.message?.content;
    if (!content) {
      throw new Error('No content from OpenAI');
    }

    const parsed = JSON.parse(content);
    
    // Handle both { strategicInitiatives: [...] } and [...] formats
    const initiativesArray = parsed.strategicInitiatives || parsed;
    
    if (!Array.isArray(initiativesArray)) {
      throw new Error('Invalid response format: expected array of strategic initiatives');
    }

    // Debug: Log raw time horizons from LLM
    console.debug('[GAP Plan] Raw strategic initiative timings:', initiativesArray.map((si: any) => ({
      id: si.id,
      title: si.title?.substring(0, 30),
      timeHorizon: si.timeHorizon || 'missing'
    })));

    // Validate and ensure all required fields
    const validatedInitiatives: StrategicInitiative[] = initiativesArray.slice(0, 5).map((si: any, index: number) => {
      // Normalize timeHorizon - accept variants and normalize to canonical format
      const rawTimeHorizon = si.timeHorizon;
      const normalizedTimeHorizon = normalizeTimeHorizon(rawTimeHorizon);
      
      return {
        id: si.id || `si-${index + 1}`,
        title: si.title || `Strategic Initiative ${index + 1}`,
        description: si.description || '',
        priority: (si.priority === 'low' || si.priority === 'medium' || si.priority === 'high') ? si.priority : 'high',
        // Normalize timeHorizon, but ensure it's either medium_term or long_term for strategic initiatives
        timeHorizon: (normalizedTimeHorizon === 'medium_term' || normalizedTimeHorizon === 'long_term') 
          ? normalizedTimeHorizon 
          : 'medium_term' as 'medium_term' | 'long_term',
        impact: (si.impact === 'low' || si.impact === 'medium' || si.impact === 'high') ? si.impact : 'high',
        resourceRequirement: (si.resourceRequirement === 'minimal' || si.resourceRequirement === 'moderate' || si.resourceRequirement === 'significant') ? si.resourceRequirement : 'moderate',
        specificChanges: Array.isArray(si.specificChanges) ? si.specificChanges : [si.specificChanges || ''],
        expectedOutcome: si.expectedOutcome || '',
        successMetrics: Array.isArray(si.successMetrics) ? si.successMetrics.filter((m: string) => m && !m.includes('Metric 1') && !m.includes('Metric 2')) : [],
        potentialScoreGain: typeof si.potentialScoreGain === 'number' && si.potentialScoreGain > 0 ? si.potentialScoreGain : undefined, // Only use if LLM provided a value
        estimatedEffort: si.estimatedEffort || '6-8 weeks',
        serviceArea: (si.serviceArea === 'brandingAndImpact' || si.serviceArea === 'contentAndEngagement' || si.serviceArea === 'websiteAndConversion' || si.serviceArea === 'seoAndVisibility') ? si.serviceArea : 'cross_cutting',
        totalDuration: si.totalDuration || '90 days',
        investmentLevel: (si.investmentLevel === 'low' || si.investmentLevel === 'medium' || si.investmentLevel === 'high') ? si.investmentLevel : 'medium',
        expectedROI: si.expectedROI || 'Moderate to high ROI expected',
      };
    });

    console.log(`‚úÖ Generated ${validatedInitiatives.length} strategic initiatives`);
    return validatedInitiatives;
  } catch (error: any) {
    // Check if it's a timeout error - if so, return empty array (outer Promise.race will handle it)
    if (error?.message?.includes('timed out') || error?.message?.includes('Request timed out')) {
      console.warn('‚ö†Ô∏è  Strategic initiatives generation timed out, using fallback');
      return [];
    }
    console.error('‚ùå Error generating strategic initiatives with AI:', error);
    // Fallback to basic strategic initiatives if AI fails
    console.log('‚ö†Ô∏è  Falling back to basic strategic initiatives from assessment');
    return assessment.globalRoadmap.slice(0, 3).map((item, index) => ({
      id: `si-${index + 1}`,
      title: item.action,
      description: item.specific_changes,
      priority: item.impact === 'high' ? 'high' : 'medium' as const,
      timeHorizon: 'medium_term' as const,
      impact: item.impact === 'high' ? 'high' : 'medium' as const,
      resourceRequirement: 'moderate' as const,
      specificChanges: [item.specific_changes],
      expectedOutcome: `Complete ${item.action.toLowerCase()} initiative`,
      successMetrics: ['Implementation complete', 'Results tracked'],
      potentialScoreGain: item.potentialGain,
      estimatedEffort: '6-8 weeks',
      serviceArea: item.service,
      totalDuration: '90 days',
      investmentLevel: 'medium' as const,
      expectedROI: 'Moderate to high ROI expected',
    }));
  }
}

/**
 * Organize actions into focus areas (grouped by theme)
 * TODO: Implement with AI prompt
 */
export function generateFocusAreas(
  assessment: AssessmentResult,
  quickWins: QuickWin[],
  strategicInitiatives: StrategicInitiative[]
): GrowthFocusArea[] {
  // Stub - will be implemented with AI prompt
  return [
    {
      id: 'content-strategy',
      name: 'Content Strategy & Authority',
      description: 'Build content depth and authority to improve SEO and engagement',
      priority: 'high' as const,
      actions: [...quickWins.filter(qw => qw.serviceArea === 'contentAndEngagement'), ...strategicInitiatives.filter(si => si.serviceArea === 'contentAndEngagement')],
      expectedImpact: 'Improved content depth and SEO authority',
      successCriteria: [], // Let LLM generate based on actual content strategy
    },
    {
      id: 'conversion-optimization',
      name: 'Conversion Optimization',
      description: 'Optimize conversion funnels and CTAs to improve conversion rates',
      priority: 'high' as const,
      actions: [...quickWins.filter(qw => qw.serviceArea === 'websiteAndConversion'), ...strategicInitiatives.filter(si => si.serviceArea === 'websiteAndConversion')],
      expectedImpact: 'Improved conversion rates and user experience',
      successCriteria: [], // Let LLM generate based on actual conversion issues
    },
  ];
}

/**
 * Identify resource requirements for all actions
 * TODO: Implement with AI prompt
 */
export function generateResourceRequirements(
  assessment: AssessmentResult,
  quickWins: QuickWin[],
  strategicInitiatives: StrategicInitiative[]
): ResourceRequirement[] {
  const requirements: ResourceRequirement[] = [];
  
  // Extract actual resource requirements from initiatives
  strategicInitiatives.forEach(si => {
    if (si.resourceRequirement === 'significant') {
      requirements.push({
        type: 'internal',
        description: `Team capacity for: ${si.title}`,
        estimatedCost: 'To be determined based on team availability', // Don't hardcode costs
        urgency: si.priority === 'high' ? 'immediate' as const : 'soon' as const,
      });
    }
    
    // Extract required skills as separate requirements
    if (si.requiredSkills && si.requiredSkills.length > 0) {
      requirements.push({
        type: 'internal',
        description: `${si.requiredSkills.join(', ')} capability needed for: ${si.title}`,
        estimatedCost: 'Existing team or training required', // Don't hardcode costs
        urgency: 'soon' as const,
      });
    }
  });
  
  // Only add tool requirements if initiatives specifically mention them
  const toolMentions = [...quickWins, ...strategicInitiatives].some(item => 
    item.description.toLowerCase().includes('tool') || 
    item.description.toLowerCase().includes('software') ||
    item.description.toLowerCase().includes('platform')
  );
  
  if (toolMentions) {
    requirements.push({
      type: 'tool',
      description: 'Tools or software mentioned in initiatives (review specific needs per initiative)',
      estimatedCost: 'Cost varies by tool selection', // Don't hardcode specific costs
      urgency: 'soon' as const,
    });
  }
  
  return requirements; // Return empty if no specific requirements identified
}

/**
 * Build timeline from quick wins and strategic initiatives
 * 
 * Maps each action to the correct timeline bucket based on its timeHorizon:
 * - immediate ‚Üí timeline.immediate
 * - short_term ‚Üí timeline.shortTerm
 * - medium_term ‚Üí timeline.mediumTerm
 * - long_term ‚Üí timeline.longTerm
 * 
 * IMPORTANT: Never overrides or changes the timeHorizon value from the original quickWin/initiative.
 * The timeHorizon is preserved exactly as provided.
 */
export function buildTimeline(
  quickWins: QuickWin[],
  strategicInitiatives: StrategicInitiative[]
): GrowthAccelerationPlan['timeline'] {
  // Combine all actions (quick wins and strategic initiatives)
  // Both QuickWin and StrategicInitiative extend GrowthAction, so we can treat them as GrowthAction[]
  const allActions: GrowthAction[] = [...quickWins, ...strategicInitiatives];
  
  // Map each action to the correct timeline bucket based on its timeHorizon
  // Never override or change the timeHorizon value - preserve it exactly as provided
  const immediate: GrowthAction[] = [];
  const shortTerm: GrowthAction[] = [];
  const mediumTerm: GrowthAction[] = [];
  const longTerm: GrowthAction[] = [];
  
  for (const action of allActions) {
    // Actions should already have normalized timeHorizon values from parsing
    // (normalized via normalizeTimeHorizon function in quick wins/strategic initiatives parsing)
    switch (action.timeHorizon) {
      case 'immediate':
        immediate.push(action);
        break;
      case 'short_term':
        shortTerm.push(action);
        break;
      case 'medium_term':
        mediumTerm.push(action);
        break;
      case 'long_term':
        longTerm.push(action);
        break;
      default: {
        // Fallback: if timeHorizon is invalid, normalize it and assign to appropriate bucket
        const normalized = normalizeTimeHorizon((action as any).timeHorizon);
        console.warn(`‚ö†Ô∏è  Invalid timeHorizon "${(action as any).timeHorizon}" for action "${action.id}", normalized to "${normalized}"`);
        // Update the action's timeHorizon to the normalized value
        (action as any).timeHorizon = normalized;
        // Assign to appropriate bucket
        switch (normalized) {
          case 'immediate':
            immediate.push(action);
            break;
          case 'short_term':
            shortTerm.push(action);
            break;
          case 'medium_term':
            mediumTerm.push(action);
            break;
          case 'long_term':
            longTerm.push(action);
            break;
        }
      }
    }
  }
  
  // Debug: Log distribution after grouping
  console.debug('[GAP Plan] Timeline distribution:', {
    immediate: immediate.length,
    shortTerm: shortTerm.length,
    mediumTerm: mediumTerm.length,
    longTerm: longTerm.length,
    total: allActions.length,
  });
  
  return {
    immediate,
    shortTerm,
    mediumTerm,
    longTerm,
  };
}

/**
 * Calculate expected outcomes at 30/90/180 day milestones
 * Respects data availability and caps projections based on confidence level
 */
export function calculateExpectedOutcomes(
  assessment: AssessmentResult,
  quickWins: QuickWin[],
  strategicInitiatives: StrategicInitiative[],
  dataAvailability: DataAvailability
): GrowthAccelerationPlan['expectedOutcomes'] {
  // Only sum score gains that were actually provided by LLM (not hardcoded defaults)
  const quickWinGain = quickWins.reduce((sum, qw) => sum + (qw.potentialScoreGain ?? 0), 0);
  const strategicGain = strategicInitiatives.reduce((sum, si) => sum + (si.potentialScoreGain ?? 0), 0);
  
  // If no score gains were provided, estimate conservatively based on number of initiatives
  // This is algorithmic, not hardcoded to a specific site
  const estimatedQuickWinGain = quickWinGain > 0 ? quickWinGain : Math.min(quickWins.length * 2, 10);
  const estimatedStrategicGain = strategicGain > 0 ? strategicGain : Math.min(strategicInitiatives.length * 3, 20);

  // Cap score improvements based on confidence level
  let maxImprovement: number;
  switch (dataAvailability.overallConfidence) {
    case 'low':
      // Low confidence: cap at 15 points for 90 days, 25 for 6 months
      maxImprovement = 25;
      break;
    case 'medium':
      // Medium confidence: cap at 30 points for 90 days, 40 for 6 months
      maxImprovement = 40;
      break;
    case 'high':
      // High confidence: allow up to 50 points for 6 months
      maxImprovement = 50;
      break;
    default:
      maxImprovement = 30; // Default to medium
  }

  // Calculate raw improvements using estimated gains if LLM didn't provide specific values
  const rawThirtyDays = Math.min(estimatedQuickWinGain, maxImprovement * 0.3);
  const rawNinetyDays = Math.min(estimatedQuickWinGain + Math.floor(estimatedStrategicGain * 0.5), maxImprovement * 0.6);
  const rawSixMonths = Math.min(estimatedQuickWinGain + estimatedStrategicGain, maxImprovement);

  // Generate metrics and milestones based on actual quick wins and initiatives
  const thirtyDayMetrics: string[] = [];
  const ninetyDayMetrics: string[] = [];
  const sixMonthMetrics: string[] = [];
  
  // Extract actual metrics from quick wins and initiatives
  quickWins.forEach(qw => {
    if (qw.successMetrics && qw.successMetrics.length > 0) {
      thirtyDayMetrics.push(...qw.successMetrics.slice(0, 2));
    }
  });
  
  strategicInitiatives.forEach(si => {
    if (si.successMetrics && si.successMetrics.length > 0) {
      ninetyDayMetrics.push(...si.successMetrics.slice(0, 2));
      sixMonthMetrics.push(...si.successMetrics.slice(0, 2));
    }
  });

  return {
    thirtyDays: {
      scoreImprovement: Math.round(rawThirtyDays),
      keyMetrics: thirtyDayMetrics.length > 0 ? thirtyDayMetrics : [], // Use actual metrics from quick wins
      milestones: quickWins.length > 0 
        ? quickWins.slice(0, 2).map(qw => `Complete: ${qw.title}`)
        : [], // Use actual quick win titles
    },
    ninetyDays: {
      scoreImprovement: Math.round(rawNinetyDays),
      keyMetrics: ninetyDayMetrics.length > 0 ? ninetyDayMetrics : [], // Use actual metrics from initiatives
      milestones: strategicInitiatives.length > 0
        ? strategicInitiatives.slice(0, 2).map(si => `Launch: ${si.title}`)
        : [], // Use actual initiative titles
    },
    sixMonths: {
      scoreImprovement: Math.round(rawSixMonths),
      keyMetrics: sixMonthMetrics.length > 0 ? sixMonthMetrics : [], // Use actual metrics from initiatives
      milestones: strategicInitiatives.length > 0
        ? strategicInitiatives.map(si => `Complete: ${si.title}`)
        : [], // Use actual initiative titles
    },
  };
}

/**
 * Identify risks and mitigation strategies
 * Based on actual quick wins and strategic initiatives, not hardcoded risks
 */
export function identifyRisks(
  assessment: AssessmentResult,
  quickWins: QuickWin[],
  strategicInitiatives: StrategicInitiative[]
): GrowthAccelerationPlan['risks'] {
  // Generate risks based on actual initiatives and their dependencies
  const risks: GrowthAccelerationPlan['risks'] = [];
  
  // Check for resource-intensive initiatives
  const resourceIntensive = strategicInitiatives.filter(si => 
    si.resourceRequirement === 'significant'
  );
  if (resourceIntensive.length > 0) {
    risks.push({
      risk: `Resource requirements for ${resourceIntensive[0].title} may be challenging`,
      mitigation: 'Prioritize quick wins first, phase strategic initiatives based on available capacity',
      likelihood: 'medium' as const,
      impact: 'high' as const,
    });
  }
  
  // Check for dependencies
  const hasDependencies = strategicInitiatives.some(si => 
    si.dependencies && si.dependencies.length > 0
  );
  if (hasDependencies) {
    risks.push({
      risk: 'Some initiatives depend on others completing first',
      mitigation: 'Follow the recommended timeline and complete dependencies before dependent initiatives',
      likelihood: 'medium' as const,
      impact: 'medium' as const,
    });
  }
  
  // If no specific risks identified, return empty array (don't invent generic risks)
  return risks;
}

/**
 * Generate immediate next steps to get started
 * Based on actual quick wins and strategic initiatives, not hardcoded steps
 */
export function generateNextSteps(quickWins: QuickWin[], strategicInitiatives: StrategicInitiative[]): string[] {
  const nextSteps: string[] = [];
  
  // Use actual quick win titles as next steps
  if (quickWins.length > 0) {
    nextSteps.push(`Start with: ${quickWins[0].title}`);
    if (quickWins.length > 1) {
      nextSteps.push(`Then: ${quickWins[1].title}`);
    }
  }
  
  // Add steps based on actual initiatives if they have specific requirements
  strategicInitiatives.slice(0, 2).forEach(si => {
    if (si.requiredSkills && si.requiredSkills.length > 0) {
      nextSteps.push(`Ensure ${si.requiredSkills[0]} capability for: ${si.title}`);
    }
  });
  
  // Only add generic steps if we have actual actions to track
  if (quickWins.length > 0 || strategicInitiatives.length > 0) {
    nextSteps.push('Set up tracking for the metrics defined in each initiative');
  }
  
  return nextSteps.length > 0 ? nextSteps : []; // Don't invent steps if none exist
}

