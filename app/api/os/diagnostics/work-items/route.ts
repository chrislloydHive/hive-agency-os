// app/api/os/diagnostics/work-items/route.ts
// Create Work Items from diagnostic AI insights
//
// This endpoint allows creating work items from suggested work items
// generated by the AI insights system.

import { NextRequest, NextResponse } from 'next/server';
import {
  createWorkItemFromDiagnosticInsight,
  type SuggestedWorkItemInput,
} from '@/lib/airtable/workItems';
import { isValidToolId } from '@/lib/os/diagnostics/runs';

interface CreateWorkItemRequest {
  companyId: string;
  toolId: string;
  diagnosticRunId?: string;
  suggestedItem: SuggestedWorkItemInput;
}

interface CreateWorkItemsRequest {
  companyId: string;
  toolId: string;
  diagnosticRunId?: string;
  suggestedItems: SuggestedWorkItemInput[];
}

export async function POST(request: NextRequest) {
  try {
    const body = await request.json();

    // Support both single and bulk creation
    if ('suggestedItems' in body) {
      // Bulk creation
      return handleBulkCreate(body as CreateWorkItemsRequest);
    } else {
      // Single creation
      return handleSingleCreate(body as CreateWorkItemRequest);
    }
  } catch (error) {
    console.error('[Work Items API] Error:', error);
    return NextResponse.json(
      { error: error instanceof Error ? error.message : 'Failed to create work item(s)' },
      { status: 500 }
    );
  }
}

async function handleSingleCreate(body: CreateWorkItemRequest) {
  const { companyId, toolId, diagnosticRunId, suggestedItem } = body;

  // Validate required fields
  if (!companyId) {
    return NextResponse.json({ error: 'Missing companyId' }, { status: 400 });
  }

  if (!toolId) {
    return NextResponse.json({ error: 'Missing toolId' }, { status: 400 });
  }

  if (!suggestedItem || !suggestedItem.title) {
    return NextResponse.json({ error: 'Missing or invalid suggestedItem' }, { status: 400 });
  }

  // Validate toolId
  if (!isValidToolId(toolId)) {
    return NextResponse.json({ error: `Invalid toolId: ${toolId}` }, { status: 400 });
  }

  // Create work item
  const workItem = await createWorkItemFromDiagnosticInsight({
    companyId,
    toolId,
    diagnosticRunId,
    suggestedItem,
  });

  return NextResponse.json({
    success: true,
    workItem,
  });
}

async function handleBulkCreate(body: CreateWorkItemsRequest) {
  const { companyId, toolId, diagnosticRunId, suggestedItems } = body;

  // Validate required fields
  if (!companyId) {
    return NextResponse.json({ error: 'Missing companyId' }, { status: 400 });
  }

  if (!toolId) {
    return NextResponse.json({ error: 'Missing toolId' }, { status: 400 });
  }

  if (!suggestedItems || !Array.isArray(suggestedItems) || suggestedItems.length === 0) {
    return NextResponse.json({ error: 'Missing or invalid suggestedItems array' }, { status: 400 });
  }

  // Validate toolId
  if (!isValidToolId(toolId)) {
    return NextResponse.json({ error: `Invalid toolId: ${toolId}` }, { status: 400 });
  }

  // Create work items
  const results = await Promise.allSettled(
    suggestedItems.map((item) =>
      createWorkItemFromDiagnosticInsight({
        companyId,
        toolId,
        diagnosticRunId,
        suggestedItem: item,
      })
    )
  );

  const created = results
    .filter((r): r is PromiseFulfilledResult<Awaited<ReturnType<typeof createWorkItemFromDiagnosticInsight>>> => r.status === 'fulfilled')
    .map((r) => r.value);

  const failed = results
    .filter((r): r is PromiseRejectedResult => r.status === 'rejected')
    .map((r) => r.reason?.message || 'Unknown error');

  return NextResponse.json({
    success: failed.length === 0,
    created,
    failedCount: failed.length,
    errors: failed.length > 0 ? failed : undefined,
  });
}
